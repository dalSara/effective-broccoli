'use strict';

exports.__esModule = true;
exports.assign = assign;
exports.shouldRegressHttps = shouldRegressHttps;
exports.regressHttps = regressHttps;
exports.resetKeepAliveConnections = resetKeepAliveConnections;

var _yakaa = require('yakaa');

var _yakaa2 = _interopRequireDefault(_yakaa);

var _lruCache = require('lru-cache');

var _lruCache2 = _interopRequireDefault(_lruCache);

var _tunnelAgent = require('tunnel-agent');

var _tunnelAgent2 = _interopRequireDefault(_tunnelAgent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Const
var SSL3_HOST_CACHE_SIZE = 1000;

var TYPE = {
    SSL3: 'SSL3',
    TLS: 'TLS',
    HTTP: 'HTTP'
};

// Static
var ssl3HostCache = new _lruCache2.default({ max: SSL3_HOST_CACHE_SIZE });

// NOTE: We need an agent with proper keep-alive behavior. Such an agent has landed in Node 0.12. Since we
// still support Node 0.10, we will use a third-party agent that is the extraction of Node 0.12 Agent code.
var agents = {
    [TYPE.SSL3]: {
        instance: null,
        Ctor: _yakaa2.default.SSL,
        secureProtocol: 'SSLv3_method'
    },

    [TYPE.TLS]: {
        instance: null,
        Ctor: _yakaa2.default.SSL
    },

    [TYPE.HTTP]: {
        instance: null,
        Ctor: _yakaa2.default
    }
};

// Utils
function getAgent(type) {
    var agent = agents[type];

    if (!agent.instance) {
        agent.instance = new agent.Ctor({
            keepAlive: true,
            secureProtocol: agent.secureProtocol
        });
    }

    return agent.instance;
}

function isSSLProtocolErr(err) {
    return err.message && err.message.includes('SSL routines');
}

// API
function assign(reqOpts) {
    var proxy = reqOpts.proxy;

    if (proxy && reqOpts.protocol === 'https:') {
        reqOpts.agent = _tunnelAgent2.default.httpsOverHttp({ proxy });

        return;
    }

    var type = void 0;

    if (reqOpts.protocol === 'http:') type = TYPE.HTTP;else if (ssl3HostCache.get(reqOpts.host)) type = TYPE.SSL3;else type = TYPE.TLS;

    reqOpts.agent = getAgent(type);
}

function shouldRegressHttps(reqErr, reqOpts) {
    return reqOpts.agent === agents[TYPE.TLS] && isSSLProtocolErr(reqErr);
}

function regressHttps(reqOpts) {
    ssl3HostCache.set(reqOpts.host, true);
    reqOpts.agent = getAgent(TYPE.SSL3);
}

// NOTE: Since our agents are keep-alive, we need to manually reset connections when we
// switch between servers in tests.
function resetKeepAliveConnections() {
    Object.keys(agents).forEach(function (type) {
        var agent = agents[type];

        if (agent.instance) agent.instance.destroy();

        agent.instance = null;
    });
}