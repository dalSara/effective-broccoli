'use strict';

exports.__esModule = true;

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _pinkie = require('pinkie');

var _pinkie2 = _interopRequireDefault(_pinkie);

var _pngjs = require('pngjs');

var _promisifyEvent = require('promisify-event');

var _promisifyEvent2 = _interopRequireDefault(_promisifyEvent);

var _limitNumber = require('../utils/limit-number');

var _limitNumber2 = _interopRequireDefault(_limitNumber);

var _promisifiedFunctions = require('../utils/promisified-functions');

var _renderTemplate = require('../utils/render-template');

var _renderTemplate2 = _interopRequireDefault(_renderTemplate);

var _testRun = require('../errors/test-run/');

var _constants = require('./constants');

var _warningMessage = require('../notifications/warning-message');

var _warningMessage2 = _interopRequireDefault(_warningMessage);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function readPng(filePath) {
    const png = new _pngjs.PNG();
    const parsedPromise = _pinkie2.default.race([(0, _promisifyEvent2.default)(png, 'parsed'), (0, _promisifyEvent2.default)(png, 'error')]);

    _fs2.default.createReadStream(filePath).pipe(png);

    return parsedPromise.then(() => png);
}

function writePng(filePath, png) {
    const outStream = _fs2.default.createWriteStream(filePath);
    const finishPromise = _pinkie2.default.race([(0, _promisifyEvent2.default)(outStream, 'finish'), (0, _promisifyEvent2.default)(outStream, 'error')]);

    png.pack().pipe(outStream);

    return finishPromise;
}

function markSeedToId(markSeed) {
    let id = 0;

    for (let i = 0; i < _constants.MARK_LENGTH; i++) id = id * 2 + (markSeed[i * _constants.MARK_BYTES_PER_PIXEL] ? 1 : 0);

    return id;
}

function detectClippingArea(srcImage, { markSeed, clientAreaDimensions, cropDimensions, screenshotPath } = {}) {
    let clipLeft = 0;
    let clipTop = 0;
    let clipRight = srcImage.width;
    let clipBottom = srcImage.height;
    let clipWidth = srcImage.width;
    let clipHeight = srcImage.height;

    if (markSeed && clientAreaDimensions) {
        const mark = Buffer.from(markSeed);

        const markIndex = srcImage.data.indexOf(mark);

        if (markIndex < 0) throw new Error((0, _renderTemplate2.default)(_warningMessage2.default.screenshotMarkNotFound, screenshotPath, markSeedToId(markSeed)));

        const endPosition = markIndex / _constants.MARK_BYTES_PER_PIXEL + _constants.MARK_LENGTH + _constants.MARK_RIGHT_MARGIN;

        clipRight = endPosition % srcImage.width || srcImage.width;
        clipBottom = (endPosition - clipRight) / srcImage.width + 1;
        clipLeft = clipRight - clientAreaDimensions.width;
        clipTop = clipBottom - clientAreaDimensions.height;
    }

    const markLineNumber = clipBottom;

    if (cropDimensions) {
        clipRight = (0, _limitNumber2.default)(clipLeft + cropDimensions.right, clipLeft, clipRight);
        clipBottom = (0, _limitNumber2.default)(clipTop + cropDimensions.bottom, clipTop, clipBottom);
        clipLeft = (0, _limitNumber2.default)(clipLeft + cropDimensions.left, clipLeft, clipRight);
        clipTop = (0, _limitNumber2.default)(clipTop + cropDimensions.top, clipTop, clipBottom);
    }

    if (markSeed && clipBottom === markLineNumber) clipBottom -= 1;

    clipWidth = clipRight - clipLeft;
    clipHeight = clipBottom - clipTop;

    return {
        left: clipLeft,
        top: clipTop,
        right: clipRight,
        bottom: clipBottom,
        width: clipWidth,
        height: clipHeight
    };
}

function copyImagePart(srcImage, { left, top, width, height }) {
    const dstImage = new _pngjs.PNG({ width, height });
    const stride = dstImage.width * _constants.MARK_BYTES_PER_PIXEL;

    for (let i = 0; i < height; i++) {
        const srcStartIndex = (srcImage.width * (i + top) + left) * _constants.MARK_BYTES_PER_PIXEL;

        srcImage.data.copy(dstImage.data, stride * i, srcStartIndex, srcStartIndex + stride);
    }

    return dstImage;
}

exports.default = (() => {
    var _ref = (0, _asyncToGenerator3.default)(function* (screenshotPath, markSeed, clientAreaDimensions, cropDimensions) {
        const srcImage = yield readPng(screenshotPath);

        const clippingArea = detectClippingArea(srcImage, { markSeed, clientAreaDimensions, cropDimensions, screenshotPath });

        if (clippingArea.width <= 0 || clippingArea.height <= 0) {
            yield (0, _promisifiedFunctions.deleteFile)(screenshotPath);
            throw new _testRun.InvalidElementScreenshotDimensionsError(clippingArea.width, clippingArea.height);
        }

        if (!markSeed && !cropDimensions) return true;

        const dstImage = copyImagePart(srcImage, clippingArea);

        yield writePng(screenshotPath, dstImage);

        return true;
    });

    return function (_x, _x2, _x3, _x4) {
        return _ref.apply(this, arguments);
    };
})();

module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zY3JlZW5zaG90cy9jcm9wLmpzIl0sIm5hbWVzIjpbInJlYWRQbmciLCJmaWxlUGF0aCIsInBuZyIsIlBORyIsInBhcnNlZFByb21pc2UiLCJQcm9taXNlIiwicmFjZSIsImZzIiwiY3JlYXRlUmVhZFN0cmVhbSIsInBpcGUiLCJ0aGVuIiwid3JpdGVQbmciLCJvdXRTdHJlYW0iLCJjcmVhdGVXcml0ZVN0cmVhbSIsImZpbmlzaFByb21pc2UiLCJwYWNrIiwibWFya1NlZWRUb0lkIiwibWFya1NlZWQiLCJpZCIsImkiLCJNQVJLX0xFTkdUSCIsIk1BUktfQllURVNfUEVSX1BJWEVMIiwiZGV0ZWN0Q2xpcHBpbmdBcmVhIiwic3JjSW1hZ2UiLCJjbGllbnRBcmVhRGltZW5zaW9ucyIsImNyb3BEaW1lbnNpb25zIiwic2NyZWVuc2hvdFBhdGgiLCJjbGlwTGVmdCIsImNsaXBUb3AiLCJjbGlwUmlnaHQiLCJ3aWR0aCIsImNsaXBCb3R0b20iLCJoZWlnaHQiLCJjbGlwV2lkdGgiLCJjbGlwSGVpZ2h0IiwibWFyayIsIkJ1ZmZlciIsImZyb20iLCJtYXJrSW5kZXgiLCJkYXRhIiwiaW5kZXhPZiIsIkVycm9yIiwiV0FSTklOR19NRVNTQUdFUyIsInNjcmVlbnNob3RNYXJrTm90Rm91bmQiLCJlbmRQb3NpdGlvbiIsIk1BUktfUklHSFRfTUFSR0lOIiwibWFya0xpbmVOdW1iZXIiLCJyaWdodCIsImJvdHRvbSIsImxlZnQiLCJ0b3AiLCJjb3B5SW1hZ2VQYXJ0IiwiZHN0SW1hZ2UiLCJzdHJpZGUiLCJzcmNTdGFydEluZGV4IiwiY29weSIsImNsaXBwaW5nQXJlYSIsIkludmFsaWRFbGVtZW50U2NyZWVuc2hvdERpbWVuc2lvbnNFcnJvciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOztBQUNBOzs7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7OztBQUdBLFNBQVNBLE9BQVQsQ0FB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LGNBQVIsQ0FBeEI7O0FBRUEsY0FBTThCLGVBQWVsQyxtQkFBbUJDLFFBQW5CLEVBQTZCLEVBQUVOLFFBQUYsRUFBWU8sb0JBQVosRUFBa0NDLGNBQWxDLEVBQWtEQyxjQUFsRCxFQUE3QixDQUFyQjs7QUFFQSxZQUFJOEIsYUFBYTFCLEtBQWIsSUFBc0IsQ0FBdEIsSUFBMkIwQixhQUFheEIsTUFBYixJQUF1QixDQUF0RCxFQUF5RDtBQUNyRCxrQkFBTSxzQ0FBV04sY0FBWCxDQUFOO0FBQ0Esa0JBQU0sSUFBSStCLGdEQUFKLENBQTRDRCxhQUFhMUIsS0FBekQsRUFBZ0UwQixhQUFheEIsTUFBN0UsQ0FBTjtBQUNIOztBQUVELFlBQUksQ0FBQ2YsUUFBRCxJQUFhLENBQUNRLGNBQWxCLEVBQ0ksT0FBTyxJQUFQOztBQUVKLGNBQU0yQixXQUFXRCxjQUFjNUIsUUFBZCxFQUF3QmlDLFlBQXhCLENBQWpCOztBQUVBLGNBQU03QyxTQUFTZSxjQUFULEVBQXlCMEIsUUFBekIsQ0FBTjs7QUFFQSxlQUFPLElBQVA7QUFDSCxLIiwiZmlsZSI6InNjcmVlbnNob3RzL2Nyb3AuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZnMgZnJvbSAnZnMnO1xuaW1wb3J0IFByb21pc2UgZnJvbSAncGlua2llJztcbmltcG9ydCB7IFBORyB9IGZyb20gJ3BuZ2pzJztcbmltcG9ydCBwcm9taXNpZnlFdmVudCBmcm9tICdwcm9taXNpZnktZXZlbnQnO1xuaW1wb3J0IGxpbWl0TnVtYmVyIGZyb20gJy4uL3V0aWxzL2xpbWl0LW51bWJlcic7XG5pbXBvcnQgeyBkZWxldGVGaWxlIH0gZnJvbSAnLi4vdXRpbHMvcHJvbWlzaWZpZWQtZnVuY3Rpb25zJztcbmltcG9ydCByZW5kZXJUZW1wbGF0ZSBmcm9tICcuLi91dGlscy9yZW5kZXItdGVtcGxhdGUnO1xuaW1wb3J0IHsgSW52YWxpZEVsZW1lbnRTY3JlZW5zaG90RGltZW5zaW9uc0Vycm9yIH0gZnJvbSAnLi4vZXJyb3JzL3Rlc3QtcnVuLyc7XG5pbXBvcnQgeyBNQVJLX0xFTkdUSCwgTUFSS19SSUdIVF9NQVJHSU4sIE1BUktfQllURVNfUEVSX1BJWEVMIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IFdBUk5JTkdfTUVTU0FHRVMgZnJvbSAnLi4vbm90aWZpY2F0aW9ucy93YXJuaW5nLW1lc3NhZ2UnO1xuXG5cbmZ1bmN0aW9uIHJlYWRQbmcgKGZpbGVQYXRoKSB7XG4gICAgY29uc3QgcG5nICAgICAgICAgICA9IG5ldyBQTkcoKTtcbiAgICBjb25zdCBwYXJzZWRQcm9taXNlID0gUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgcHJvbWlzaWZ5RXZlbnQocG5nLCAncGFyc2VkJyksXG4gICAgICAgIHByb21pc2lmeUV2ZW50KHBuZywgJ2Vycm9yJylcbiAgICBdKTtcblxuICAgIGZzLmNyZWF0ZVJlYWRTdHJlYW0oZmlsZVBhdGgpLnBpcGUocG5nKTtcblxuICAgIHJldHVybiBwYXJzZWRQcm9taXNlXG4gICAgICAgIC50aGVuKCgpID0+IHBuZyk7XG59XG5cbmZ1bmN0aW9uIHdyaXRlUG5nIChmaWxlUGF0aCwgcG5nKSB7XG4gICAgY29uc3Qgb3V0U3RyZWFtICAgICA9IGZzLmNyZWF0ZVdyaXRlU3RyZWFtKGZpbGVQYXRoKTtcbiAgICBjb25zdCBmaW5pc2hQcm9taXNlID0gUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgcHJvbWlzaWZ5RXZlbnQob3V0U3RyZWFtLCAnZmluaXNoJyksXG4gICAgICAgIHByb21pc2lmeUV2ZW50KG91dFN0cmVhbSwgJ2Vycm9yJylcbiAgICBdKTtcblxuICAgIHBuZy5wYWNrKCkucGlwZShvdXRTdHJlYW0pO1xuXG4gICAgcmV0dXJuIGZpbmlzaFByb21pc2U7XG59XG5cbmZ1bmN0aW9uIG1hcmtTZWVkVG9JZCAobWFya1NlZWQpIHtcbiAgICBsZXQgaWQgPSAwO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBNQVJLX0xFTkdUSDsgaSsrKVxuICAgICAgICBpZCA9IGlkICogMiArIChtYXJrU2VlZFtpICogTUFSS19CWVRFU19QRVJfUElYRUxdID8gMSA6IDApO1xuXG4gICAgcmV0dXJuIGlkO1xufVxuXG5mdW5jdGlvbiBkZXRlY3RDbGlwcGluZ0FyZWEgKHNyY0ltYWdlLCB7IG1hcmtTZWVkLCBjbGllbnRBcmVhRGltZW5zaW9ucywgY3JvcERpbWVuc2lvbnMsIHNjcmVlbnNob3RQYXRoIH0gPSB7fSkge1xuICAgIGxldCBjbGlwTGVmdCAgID0gMDtcbiAgICBsZXQgY2xpcFRvcCAgICA9IDA7XG4gICAgbGV0IGNsaXBSaWdodCAgPSBzcmNJbWFnZS53aWR0aDtcbiAgICBsZXQgY2xpcEJvdHRvbSA9IHNyY0ltYWdlLmhlaWdodDtcbiAgICBsZXQgY2xpcFdpZHRoICA9IHNyY0ltYWdlLndpZHRoO1xuICAgIGxldCBjbGlwSGVpZ2h0ID0gc3JjSW1hZ2UuaGVpZ2h0O1xuXG4gICAgaWYgKG1hcmtTZWVkICYmIGNsaWVudEFyZWFEaW1lbnNpb25zKSB7XG4gICAgICAgIGNvbnN0IG1hcmsgPSBCdWZmZXIuZnJvbShtYXJrU2VlZCk7XG5cbiAgICAgICAgY29uc3QgbWFya0luZGV4ID0gc3JjSW1hZ2UuZGF0YS5pbmRleE9mKG1hcmspO1xuXG4gICAgICAgIGlmIChtYXJrSW5kZXggPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlbmRlclRlbXBsYXRlKFdBUk5JTkdfTUVTU0FHRVMuc2NyZWVuc2hvdE1hcmtOb3RGb3VuZCwgc2NyZWVuc2hvdFBhdGgsIG1hcmtTZWVkVG9JZChtYXJrU2VlZCkpKTtcblxuICAgICAgICBjb25zdCBlbmRQb3NpdGlvbiA9IG1hcmtJbmRleCAvIE1BUktfQllURVNfUEVSX1BJWEVMICsgTUFSS19MRU5HVEggKyBNQVJLX1JJR0hUX01BUkdJTjtcblxuICAgICAgICBjbGlwUmlnaHQgID0gZW5kUG9zaXRpb24gJSBzcmNJbWFnZS53aWR0aCB8fCBzcmNJbWFnZS53aWR0aDtcbiAgICAgICAgY2xpcEJvdHRvbSA9IChlbmRQb3NpdGlvbiAtIGNsaXBSaWdodCkgLyBzcmNJbWFnZS53aWR0aCArIDE7XG4gICAgICAgIGNsaXBMZWZ0ICAgPSBjbGlwUmlnaHQgLSBjbGllbnRBcmVhRGltZW5zaW9ucy53aWR0aDtcbiAgICAgICAgY2xpcFRvcCAgICA9IGNsaXBCb3R0b20gLSBjbGllbnRBcmVhRGltZW5zaW9ucy5oZWlnaHQ7XG4gICAgfVxuXG4gICAgY29uc3QgbWFya0xpbmVOdW1iZXIgPSBjbGlwQm90dG9tO1xuXG4gICAgaWYgKGNyb3BEaW1lbnNpb25zKSB7XG4gICAgICAgIGNsaXBSaWdodCAgPSBsaW1pdE51bWJlcihjbGlwTGVmdCArIGNyb3BEaW1lbnNpb25zLnJpZ2h0LCBjbGlwTGVmdCwgY2xpcFJpZ2h0KTtcbiAgICAgICAgY2xpcEJvdHRvbSA9IGxpbWl0TnVtYmVyKGNsaXBUb3AgKyBjcm9wRGltZW5zaW9ucy5ib3R0b20sIGNsaXBUb3AsIGNsaXBCb3R0b20pO1xuICAgICAgICBjbGlwTGVmdCAgID0gbGltaXROdW1iZXIoY2xpcExlZnQgKyBjcm9wRGltZW5zaW9ucy5sZWZ0LCBjbGlwTGVmdCwgY2xpcFJpZ2h0KTtcbiAgICAgICAgY2xpcFRvcCAgICA9IGxpbWl0TnVtYmVyKGNsaXBUb3AgKyBjcm9wRGltZW5zaW9ucy50b3AsIGNsaXBUb3AsIGNsaXBCb3R0b20pO1xuICAgIH1cblxuICAgIGlmIChtYXJrU2VlZCAmJiBjbGlwQm90dG9tID09PSBtYXJrTGluZU51bWJlcilcbiAgICAgICAgY2xpcEJvdHRvbSAtPSAxO1xuXG4gICAgY2xpcFdpZHRoICA9IGNsaXBSaWdodCAtIGNsaXBMZWZ0O1xuICAgIGNsaXBIZWlnaHQgPSBjbGlwQm90dG9tIC0gY2xpcFRvcDtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6ICAgY2xpcExlZnQsXG4gICAgICAgIHRvcDogICAgY2xpcFRvcCxcbiAgICAgICAgcmlnaHQ6ICBjbGlwUmlnaHQsXG4gICAgICAgIGJvdHRvbTogY2xpcEJvdHRvbSxcbiAgICAgICAgd2lkdGg6ICBjbGlwV2lkdGgsXG4gICAgICAgIGhlaWdodDogY2xpcEhlaWdodFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGNvcHlJbWFnZVBhcnQgKHNyY0ltYWdlLCB7IGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCB9KSB7XG4gICAgY29uc3QgZHN0SW1hZ2UgPSBuZXcgUE5HKHsgd2lkdGgsIGhlaWdodCB9KTtcbiAgICBjb25zdCBzdHJpZGUgICA9IGRzdEltYWdlLndpZHRoICogTUFSS19CWVRFU19QRVJfUElYRUw7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhlaWdodDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHNyY1N0YXJ0SW5kZXggPSAoc3JjSW1hZ2Uud2lkdGggKiAoaSArIHRvcCkgKyBsZWZ0KSAqIE1BUktfQllURVNfUEVSX1BJWEVMO1xuXG4gICAgICAgIHNyY0ltYWdlLmRhdGEuY29weShkc3RJbWFnZS5kYXRhLCBzdHJpZGUgKiBpLCBzcmNTdGFydEluZGV4LCBzcmNTdGFydEluZGV4ICsgc3RyaWRlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZHN0SW1hZ2U7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIChzY3JlZW5zaG90UGF0aCwgbWFya1NlZWQsIGNsaWVudEFyZWFEaW1lbnNpb25zLCBjcm9wRGltZW5zaW9ucykge1xuICAgIGNvbnN0IHNyY0ltYWdlICA9IGF3YWl0IHJlYWRQbmcoc2NyZWVuc2hvdFBhdGgpO1xuXG4gICAgY29uc3QgY2xpcHBpbmdBcmVhID0gZGV0ZWN0Q2xpcHBpbmdBcmVhKHNyY0ltYWdlLCB7IG1hcmtTZWVkLCBjbGllbnRBcmVhRGltZW5zaW9ucywgY3JvcERpbWVuc2lvbnMsIHNjcmVlbnNob3RQYXRoIH0pO1xuXG4gICAgaWYgKGNsaXBwaW5nQXJlYS53aWR0aCA8PSAwIHx8IGNsaXBwaW5nQXJlYS5oZWlnaHQgPD0gMCkge1xuICAgICAgICBhd2FpdCBkZWxldGVGaWxlKHNjcmVlbnNob3RQYXRoKTtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRFbGVtZW50U2NyZWVuc2hvdERpbWVuc2lvbnNFcnJvcihjbGlwcGluZ0FyZWEud2lkdGgsIGNsaXBwaW5nQXJlYS5oZWlnaHQpO1xuICAgIH1cblxuICAgIGlmICghbWFya1NlZWQgJiYgIWNyb3BEaW1lbnNpb25zKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNvbnN0IGRzdEltYWdlID0gY29weUltYWdlUGFydChzcmNJbWFnZSwgY2xpcHBpbmdBcmVhKTtcblxuICAgIGF3YWl0IHdyaXRlUG5nKHNjcmVlbnNob3RQYXRoLCBkc3RJbWFnZSk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbiJdfQ==
