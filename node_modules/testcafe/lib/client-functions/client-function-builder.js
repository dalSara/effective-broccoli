'use strict';

exports.__esModule = true;

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _lodash = require('lodash');

var _testRunTracker = require('../api/test-run-tracker');

var _testRunTracker2 = _interopRequireDefault(_testRunTracker);

var _builderSymbol = require('./builder-symbol');

var _builderSymbol2 = _interopRequireDefault(_builderSymbol);

var _replicator = require('./replicator');

var _observation = require('../test-run/commands/observation');

var _compileClientFunction = require('../compiler/compile-client-function');

var _compileClientFunction2 = _interopRequireDefault(_compileClientFunction);

var _runtime = require('../errors/runtime');

var _typeAssertions = require('../errors/runtime/type-assertions');

var _message = require('../errors/runtime/message');

var _message2 = _interopRequireDefault(_message);

var _getCallsite = require('../errors/get-callsite');

var _reExecutablePromise = require('../utils/re-executable-promise');

var _reExecutablePromise2 = _interopRequireDefault(_reExecutablePromise);

var _markerSymbol = require('../test-run/marker-symbol');

var _markerSymbol2 = _interopRequireDefault(_markerSymbol);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const DEFAULT_EXECUTION_CALLSITE_NAME = '__$$clientFunction$$';

class ClientFunctionBuilder {
    constructor(fn, options, callsiteNames = {}) {
        this.callsiteNames = {
            instantiation: callsiteNames.instantiation,
            execution: callsiteNames.execution || DEFAULT_EXECUTION_CALLSITE_NAME
        };

        if ((0, _lodash.isNil)(options)) options = {};

        this._validateOptions(options);

        this.fn = fn;
        this.options = options;
        this.compiledFnCode = this._getCompiledFnCode();

        if (!this.compiledFnCode) throw this._createInvalidFnTypeError();

        this.replicator = (0, _replicator.createReplicator)(this._getReplicatorTransforms());
    }

    _decorateFunction(clientFn) {
        clientFn[_builderSymbol2.default] = this;

        clientFn.with = options => {
            if (typeof options === 'object') options = (0, _lodash.assign)({}, this.options, options);

            var builder = new this.constructor(this.fn, options, {
                instantiation: 'with',
                execution: this.callsiteNames.execution
            });

            return builder.getFunction();
        };
    }

    getBoundTestRun() {
        // NOTE: `boundTestRun` can be either TestController or TestRun instance.
        if (this.options.boundTestRun) return this.options.boundTestRun.testRun || this.options.boundTestRun;

        return null;
    }

    _getTestRun() {
        return this.getBoundTestRun() || _testRunTracker2.default.resolveContextTestRun();
    }

    getFunction() {
        var builder = this;

        var clientFn = function __$$clientFunction$$() {
            var testRun = builder._getTestRun();
            var callsite = (0, _getCallsite.getCallsiteForMethod)(builder.callsiteNames.execution);
            var args = [];

            // OPTIMIZATION: don't leak `arguments` object.
            for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);

            return builder._executeCommand(args, testRun, callsite);
        };

        this._decorateFunction(clientFn);

        return clientFn;
    }

    getCommand(args) {
        var encodedArgs = this.replicator.encode(args);
        var encodedDependencies = this.replicator.encode(this.getFunctionDependencies());

        return this._createTestRunCommand(encodedArgs, encodedDependencies);
    }

    // Overridable methods
    getFunctionDependencies() {
        return this.options.dependencies || {};
    }

    _createTestRunCommand(encodedArgs, encodedDependencies) {
        return new _observation.ExecuteClientFunctionCommand({
            instantiationCallsiteName: this.callsiteNames.instantiation,
            fnCode: this.compiledFnCode,
            args: encodedArgs,
            dependencies: encodedDependencies
        }, this._getTestRun());
    }

    _getCompiledFnCode() {
        if (typeof this.fn === 'function') return (0, _compileClientFunction2.default)(this.fn.toString(), this.options.dependencies, this.callsiteNames.instantiation, this.callsiteNames.instantiation);

        return null;
    }

    _createInvalidFnTypeError() {
        return new _runtime.ClientFunctionAPIError(this.callsiteNames.instantiation, this.callsiteNames.instantiation, _message2.default.clientFunctionCodeIsNotAFunction, typeof this.fn);
    }

    _executeCommand(args, testRun, callsite) {
        var _this = this;

        // NOTE: should be kept outside of lazy promise to preserve
        // correct callsite in case of replicator error.
        var command = this.getCommand(args);

        return _reExecutablePromise2.default.fromFn((0, _asyncToGenerator3.default)(function* () {
            if (!testRun) {
                var err = new _runtime.ClientFunctionAPIError(_this.callsiteNames.execution, _this.callsiteNames.instantiation, _message2.default.clientFunctionCantResolveTestRun);

                // NOTE: force callsite here, because more likely it will
                // be impossible to resolve it by method name from a lazy promise.
                err.callsite = callsite;

                throw err;
            }

            var result = yield testRun.executeCommand(command, callsite);

            return _this._processResult(result, args);
        }));
    }

    _processResult(result) {
        return this.replicator.decode(result);
    }

    _validateOptions(options) {
        (0, _typeAssertions.assertType)(_typeAssertions.is.nonNullObject, this.callsiteNames.instantiation, '"options" argument', options);

        if (!(0, _lodash.isNil)(options.boundTestRun)) {
            // NOTE: `boundTestRun` can be either TestController or TestRun instance.
            var boundTestRun = options.boundTestRun.testRun || options.boundTestRun;

            if (!boundTestRun[_markerSymbol2.default]) throw new _runtime.APIError(this.callsiteNames.instantiation, _message2.default.invalidClientFunctionTestRunBinding);
        }

        if (!(0, _lodash.isNil)(options.dependencies)) (0, _typeAssertions.assertType)(_typeAssertions.is.nonNullObject, this.callsiteNames.instantiation, '"dependencies" option', options.dependencies);
    }

    _getReplicatorTransforms() {
        return [new _replicator.FunctionTransform(this.callsiteNames)];
    }
}
exports.default = ClientFunctionBuilder;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jbGllbnQtZnVuY3Rpb25zL2NsaWVudC1mdW5jdGlvbi1idWlsZGVyLmpzIl0sIm5hbWVzIjpbIkRFRkFVTFRfRVhFQ1VUSU9OX0NBTExTSVRFX05BTUUiLCJDbGllbnRGdW5jdGlvbkJ1aWxkZXIiLCJjb25zdHJ1Y3RvciIsImZuIiwib3B0aW9ucyIsImNhbGxzaXRlTmFtZXMiLCJpbnN0YW50aWF0aW9uIiwiZXhlY3V0aW9uIiwiX3ZhbGlkYXRlT3B0aW9ucyIsImNvbXBpbGVkRm5Db2RlIiwiX2dldENvbXBpbGVkRm5Db2RlIiwiX2NyZWF0ZUludmFsaWRGblR5cGVFcnJvciIsInJlcGxpY2F0b3IiLCJfZ2V0UmVwbGljYXRvclRyYW5zZm9ybXMiLCJfZGVjb3JhdGVGdW5jdGlvbiIsImNsaWVudEZuIiwiZnVuY3Rpb25CdWlsZGVyU3ltYm9sIiwid2l0aCIsImJ1aWxkZXIiLCJnZXRGdW5jdGlvbiIsImdldEJvdW5kVGVzdFJ1biIsImJvdW5kVGVzdFJ1biIsInRlc3RSdW4iLCJfZ2V0VGVzdFJ1biIsInRlc3RSdW5UcmFja2VyIiwicmVzb2x2ZUNvbnRleHRUZXN0UnVuIiwiX18kJGNsaWVudEZ1bmN0aW9uJCQiLCJjYWxsc2l0ZSIsImFyZ3MiLCJpIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwicHVzaCIsIl9leGVjdXRlQ29tbWFuZCIsImdldENvbW1hbmQiLCJlbmNvZGVkQXJncyIsImVuY29kZSIsImVuY29kZWREZXBlbmRlbmNpZXMiLCJnZXRGdW5jdGlvbkRlcGVuZGVuY2llcyIsIl9jcmVhdGVUZXN0UnVuQ29tbWFuZCIsImRlcGVuZGVuY2llcyIsIkV4ZWN1dGVDbGllbnRGdW5jdGlvbkNvbW1hbmQiLCJpbnN0YW50aWF0aW9uQ2FsbHNpdGVOYW1lIiwiZm5Db2RlIiwidG9TdHJpbmciLCJDbGllbnRGdW5jdGlvbkFQSUVycm9yIiwiTUVTU0FHRSIsImNsaWVudEZ1bmN0aW9uQ29kZUlzTm90QUZ1bmN0aW9uIiwiY29tbWFuZCIsIlJlRXhlY3V0YWJsZVByb21pc2UiLCJmcm9tRm4iLCJlcnIiLCJjbGllbnRGdW5jdGlvbkNhbnRSZXNvbHZlVGVzdFJ1biIsInJlc3VsdCIsImV4ZWN1dGVDb21tYW5kIiwiX3Byb2Nlc3NSZXN1bHQiLCJkZWNvZGUiLCJpcyIsIm5vbk51bGxPYmplY3QiLCJ0ZXN0UnVuTWFya2VyIiwiQVBJRXJyb3IiLCJpbnZhbGlkQ2xpZW50RnVuY3Rpb25UZXN0UnVuQmluZGluZyIsIkZ1bmN0aW9uVHJhbnNmb3JtIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7QUFDQTs7OztBQUNBOztBQUNBOztBQUNBOzs7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBRUEsTUFBTUEsa0NBQWtDLHNCQUF4Qzs7QUFFZSxNQUFNQyxxQkFBTixDQUE0QjtBQUN2Q0MsZ0JBQWFDLEVBQWIsRUFBaUJDLE9BQWpCLEVBQTBCQyxnQkFBZ0IsRUFBMUMsRUFBOEM7QUFDMUMsYUFBS0EsYUFBTCxHQUFxQjtBQUNqQkMsMkJBQWVELGNBQWNDLGFBRFo7QUFFakJDLHVCQUFlRixjQUFjRSxTQUFkLElBQTJCUDtBQUZ6QixTQUFyQjs7QUFLQSxZQUFJLG1CQUFrQkksT0FBbEIsQ0FBSixFQUNJQSxVQUFVLEVBQVY7O0FBRUosYUFBS0ksZ0JBQUwsQ0FBc0JKLE9BQXRCOztBQUVBLGFBQUtELEVBQUwsR0FBc0JBLEVBQXRCO0FBQ0EsYUFBS0MsT0FBTCxHQUFzQkEsT0FBdEI7QUFDQSxhQUFLSyxjQUFMLEdBQXNCLEtBQUtDLGtCQUFMLEVBQXRCOztBQUVBLFlBQUksQ0FBQyxLQUFLRCxjQUFWLEVBQ0ksTUFBTSxLQUFLRSx5QkFBTCxFQUFOOztBQUVKLGFBQUtDLFVBQUwsR0FBa0Isa0NBQWlCLEtBQUtDLHdCQUFMLEVBQWpCLENBQWxCO0FBQ0g7O0FBRURDLHNCQUFtQkMsUUFBbkIsRUFBNkI7QUFDekJBLGlCQUFTQyx1QkFBVCxJQUFrQyxJQUFsQzs7QUFFQUQsaUJBQVNF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QUFhLEtBQUt2RCxhQUFMLENBQW1CQyxhQUFoQyxFQUErQ3dDLGtCQUFRZSxtQ0FBdkQsQ0FBTjtBQUNQOztBQUVELFlBQUksQ0FBQyxtQkFBa0J6RCxRQUFRb0MsWUFBMUIsQ0FBTCxFQUNJLGdDQUFXaUIsbUJBQUdDLGFBQWQsRUFBNkIsS0FBS3JELGFBQUwsQ0FBbUJDLGFBQWhELEVBQStELHVCQUEvRCxFQUF3RkYsUUFBUW9DLFlBQWhHO0FBQ1A7O0FBRUQzQiwrQkFBNEI7QUFDeEIsZUFBTyxDQUNILElBQUlpRCw2QkFBSixDQUFzQixLQUFLekQsYUFBM0IsQ0FERyxDQUFQO0FBR0g7QUFwSnNDO2tCQUF0QkoscUIiLCJmaWxlIjoiY2xpZW50LWZ1bmN0aW9ucy9jbGllbnQtZnVuY3Rpb24tYnVpbGRlci5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzTmlsIGFzIGlzTnVsbE9yVW5kZWZpbmVkLCBhc3NpZ24gfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHRlc3RSdW5UcmFja2VyIGZyb20gJy4uL2FwaS90ZXN0LXJ1bi10cmFja2VyJztcbmltcG9ydCBmdW5jdGlvbkJ1aWxkZXJTeW1ib2wgZnJvbSAnLi9idWlsZGVyLXN5bWJvbCc7XG5pbXBvcnQgeyBjcmVhdGVSZXBsaWNhdG9yLCBGdW5jdGlvblRyYW5zZm9ybSB9IGZyb20gJy4vcmVwbGljYXRvcic7XG5pbXBvcnQgeyBFeGVjdXRlQ2xpZW50RnVuY3Rpb25Db21tYW5kIH0gZnJvbSAnLi4vdGVzdC1ydW4vY29tbWFuZHMvb2JzZXJ2YXRpb24nO1xuaW1wb3J0IGNvbXBpbGVDbGllbnRGdW5jdGlvbiBmcm9tICcuLi9jb21waWxlci9jb21waWxlLWNsaWVudC1mdW5jdGlvbic7XG5pbXBvcnQgeyBBUElFcnJvciwgQ2xpZW50RnVuY3Rpb25BUElFcnJvciB9IGZyb20gJy4uL2Vycm9ycy9ydW50aW1lJztcbmltcG9ydCB7IGFzc2VydFR5cGUsIGlzIH0gZnJvbSAnLi4vZXJyb3JzL3J1bnRpbWUvdHlwZS1hc3NlcnRpb25zJztcbmltcG9ydCBNRVNTQUdFIGZyb20gJy4uL2Vycm9ycy9ydW50aW1lL21lc3NhZ2UnO1xuaW1wb3J0IHsgZ2V0Q2FsbHNpdGVGb3JNZXRob2QgfSBmcm9tICcuLi9lcnJvcnMvZ2V0LWNhbGxzaXRlJztcbmltcG9ydCBSZUV4ZWN1dGFibGVQcm9taXNlIGZyb20gJy4uL3V0aWxzL3JlLWV4ZWN1dGFibGUtcHJvbWlzZSc7XG5pbXBvcnQgdGVzdFJ1bk1hcmtlciBmcm9tICcuLi90ZXN0LXJ1bi9tYXJrZXItc3ltYm9sJztcblxuY29uc3QgREVGQVVMVF9FWEVDVVRJT05fQ0FMTFNJVEVfTkFNRSA9ICdfXyQkY2xpZW50RnVuY3Rpb24kJCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENsaWVudEZ1bmN0aW9uQnVpbGRlciB7XG4gICAgY29uc3RydWN0b3IgKGZuLCBvcHRpb25zLCBjYWxsc2l0ZU5hbWVzID0ge30pIHtcbiAgICAgICAgdGhpcy5jYWxsc2l0ZU5hbWVzID0ge1xuICAgICAgICAgICAgaW5zdGFudGlhdGlvbjogY2FsbHNpdGVOYW1lcy5pbnN0YW50aWF0aW9uLFxuICAgICAgICAgICAgZXhlY3V0aW9uOiAgICAgY2FsbHNpdGVOYW1lcy5leGVjdXRpb24gfHwgREVGQVVMVF9FWEVDVVRJT05fQ0FMTFNJVEVfTkFNRVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChpc051bGxPclVuZGVmaW5lZChvcHRpb25zKSlcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcblxuICAgICAgICB0aGlzLl92YWxpZGF0ZU9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy5mbiAgICAgICAgICAgICA9IGZuO1xuICAgICAgICB0aGlzLm9wdGlvbnMgICAgICAgID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5jb21waWxlZEZuQ29kZSA9IHRoaXMuX2dldENvbXBpbGVkRm5Db2RlKCk7XG5cbiAgICAgICAgaWYgKCF0aGlzLmNvbXBpbGVkRm5Db2RlKVxuICAgICAgICAgICAgdGhyb3cgdGhpcy5fY3JlYXRlSW52YWxpZEZuVHlwZUVycm9yKCk7XG5cbiAgICAgICAgdGhpcy5yZXBsaWNhdG9yID0gY3JlYXRlUmVwbGljYXRvcih0aGlzLl9nZXRSZXBsaWNhdG9yVHJhbnNmb3JtcygpKTtcbiAgICB9XG5cbiAgICBfZGVjb3JhdGVGdW5jdGlvbiAoY2xpZW50Rm4pIHtcbiAgICAgICAgY2xpZW50Rm5bZnVuY3Rpb25CdWlsZGVyU3ltYm9sXSA9IHRoaXM7XG5cbiAgICAgICAgY2xpZW50Rm4ud2l0aCA9IG9wdGlvbnMgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICB2YXIgYnVpbGRlciA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMuZm4sIG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICBpbnN0YW50aWF0aW9uOiAnd2l0aCcsXG4gICAgICAgICAgICAgICAgZXhlY3V0aW9uOiAgICAgdGhpcy5jYWxsc2l0ZU5hbWVzLmV4ZWN1dGlvblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBidWlsZGVyLmdldEZ1bmN0aW9uKCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZ2V0Qm91bmRUZXN0UnVuICgpIHtcbiAgICAgICAgLy8gTk9URTogYGJvdW5kVGVzdFJ1bmAgY2FuIGJlIGVpdGhlciBUZXN0Q29udHJvbGxlciBvciBUZXN0UnVuIGluc3RhbmNlLlxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJvdW5kVGVzdFJ1bilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuYm91bmRUZXN0UnVuLnRlc3RSdW4gfHwgdGhpcy5vcHRpb25zLmJvdW5kVGVzdFJ1bjtcblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBfZ2V0VGVzdFJ1biAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJvdW5kVGVzdFJ1bigpIHx8IHRlc3RSdW5UcmFja2VyLnJlc29sdmVDb250ZXh0VGVzdFJ1bigpO1xuICAgIH1cblxuICAgIGdldEZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJ1aWxkZXIgPSB0aGlzO1xuXG4gICAgICAgIHZhciBjbGllbnRGbiA9IGZ1bmN0aW9uIF9fJCRjbGllbnRGdW5jdGlvbiQkICgpIHtcbiAgICAgICAgICAgIHZhciB0ZXN0UnVuICA9IGJ1aWxkZXIuX2dldFRlc3RSdW4oKTtcbiAgICAgICAgICAgIHZhciBjYWxsc2l0ZSA9IGdldENhbGxzaXRlRm9yTWV0aG9kKGJ1aWxkZXIuY2FsbHNpdGVOYW1lcy5leGVjdXRpb24pO1xuICAgICAgICAgICAgdmFyIGFyZ3MgICAgID0gW107XG5cbiAgICAgICAgICAgIC8vIE9QVElNSVpBVElPTjogZG9uJ3QgbGVhayBgYXJndW1lbnRzYCBvYmplY3QuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcblxuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkZXIuX2V4ZWN1dGVDb21tYW5kKGFyZ3MsIHRlc3RSdW4sIGNhbGxzaXRlKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9kZWNvcmF0ZUZ1bmN0aW9uKGNsaWVudEZuKTtcblxuICAgICAgICByZXR1cm4gY2xpZW50Rm47XG4gICAgfVxuXG4gICAgZ2V0Q29tbWFuZCAoYXJncykge1xuICAgICAgICB2YXIgZW5jb2RlZEFyZ3MgICAgICAgICA9IHRoaXMucmVwbGljYXRvci5lbmNvZGUoYXJncyk7XG4gICAgICAgIHZhciBlbmNvZGVkRGVwZW5kZW5jaWVzID0gdGhpcy5yZXBsaWNhdG9yLmVuY29kZSh0aGlzLmdldEZ1bmN0aW9uRGVwZW5kZW5jaWVzKCkpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVUZXN0UnVuQ29tbWFuZChlbmNvZGVkQXJncywgZW5jb2RlZERlcGVuZGVuY2llcyk7XG4gICAgfVxuXG5cbiAgICAvLyBPdmVycmlkYWJsZSBtZXRob2RzXG4gICAgZ2V0RnVuY3Rpb25EZXBlbmRlbmNpZXMgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmRlcGVuZGVuY2llcyB8fCB7fTtcbiAgICB9XG5cbiAgICBfY3JlYXRlVGVzdFJ1bkNvbW1hbmQgKGVuY29kZWRBcmdzLCBlbmNvZGVkRGVwZW5kZW5jaWVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXhlY3V0ZUNsaWVudEZ1bmN0aW9uQ29tbWFuZCh7XG4gICAgICAgICAgICBpbnN0YW50aWF0aW9uQ2FsbHNpdGVOYW1lOiB0aGlzLmNhbGxzaXRlTmFtZXMuaW5zdGFudGlhdGlvbixcbiAgICAgICAgICAgIGZuQ29kZTogICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcGlsZWRGbkNvZGUsXG4gICAgICAgICAgICBhcmdzOiAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVkQXJncyxcbiAgICAgICAgICAgIGRlcGVuZGVuY2llczogICAgICAgICAgICAgIGVuY29kZWREZXBlbmRlbmNpZXNcbiAgICAgICAgfSwgdGhpcy5fZ2V0VGVzdFJ1bigpKTtcbiAgICB9XG5cbiAgICBfZ2V0Q29tcGlsZWRGbkNvZGUgKCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuZm4gPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICByZXR1cm4gY29tcGlsZUNsaWVudEZ1bmN0aW9uKHRoaXMuZm4udG9TdHJpbmcoKSwgdGhpcy5vcHRpb25zLmRlcGVuZGVuY2llcywgdGhpcy5jYWxsc2l0ZU5hbWVzLmluc3RhbnRpYXRpb24sIHRoaXMuY2FsbHNpdGVOYW1lcy5pbnN0YW50aWF0aW9uKTtcblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBfY3JlYXRlSW52YWxpZEZuVHlwZUVycm9yICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDbGllbnRGdW5jdGlvbkFQSUVycm9yKHRoaXMuY2FsbHNpdGVOYW1lcy5pbnN0YW50aWF0aW9uLCB0aGlzLmNhbGxzaXRlTmFtZXMuaW5zdGFudGlhdGlvbiwgTUVTU0FHRS5jbGllbnRGdW5jdGlvbkNvZGVJc05vdEFGdW5jdGlvbiwgdHlwZW9mIHRoaXMuZm4pO1xuICAgIH1cblxuICAgIF9leGVjdXRlQ29tbWFuZCAoYXJncywgdGVzdFJ1biwgY2FsbHNpdGUpIHtcbiAgICAgICAgLy8gTk9URTogc2hvdWxkIGJlIGtlcHQgb3V0c2lkZSBvZiBsYXp5IHByb21pc2UgdG8gcHJlc2VydmVcbiAgICAgICAgLy8gY29ycmVjdCBjYWxsc2l0ZSBpbiBjYXNlIG9mIHJlcGxpY2F0b3IgZXJyb3IuXG4gICAgICAgIHZhciBjb21tYW5kID0gdGhpcy5nZXRDb21tYW5kKGFyZ3MpO1xuXG4gICAgICAgIHJldHVybiBSZUV4ZWN1dGFibGVQcm9taXNlLmZyb21Gbihhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRlc3RSdW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyID0gbmV3IENsaWVudEZ1bmN0aW9uQVBJRXJyb3IodGhpcy5jYWxsc2l0ZU5hbWVzLmV4ZWN1dGlvbiwgdGhpcy5jYWxsc2l0ZU5hbWVzLmluc3RhbnRpYXRpb24sIE1FU1NBR0UuY2xpZW50RnVuY3Rpb25DYW50UmVzb2x2ZVRlc3RSdW4pO1xuXG4gICAgICAgICAgICAgICAgLy8gTk9URTogZm9yY2UgY2FsbHNpdGUgaGVyZSwgYmVjYXVzZSBtb3JlIGxpa2VseSBpdCB3aWxsXG4gICAgICAgICAgICAgICAgLy8gYmUgaW1wb3NzaWJsZSB0byByZXNvbHZlIGl0IGJ5IG1ldGhvZCBuYW1lIGZyb20gYSBsYXp5IHByb21pc2UuXG4gICAgICAgICAgICAgICAgZXJyLmNhbGxzaXRlID0gY2FsbHNpdGU7XG5cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBhd2FpdCB0ZXN0UnVuLmV4ZWN1dGVDb21tYW5kKGNvbW1hbmQsIGNhbGxzaXRlKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2Nlc3NSZXN1bHQocmVzdWx0LCBhcmdzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgX3Byb2Nlc3NSZXN1bHQgKHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXBsaWNhdG9yLmRlY29kZShyZXN1bHQpO1xuICAgIH1cblxuICAgIF92YWxpZGF0ZU9wdGlvbnMgKG9wdGlvbnMpIHtcbiAgICAgICAgYXNzZXJ0VHlwZShpcy5ub25OdWxsT2JqZWN0LCB0aGlzLmNhbGxzaXRlTmFtZXMuaW5zdGFudGlhdGlvbiwgJ1wib3B0aW9uc1wiIGFyZ3VtZW50Jywgb3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChvcHRpb25zLmJvdW5kVGVzdFJ1bikpIHtcbiAgICAgICAgICAgIC8vIE5PVEU6IGBib3VuZFRlc3RSdW5gIGNhbiBiZSBlaXRoZXIgVGVzdENvbnRyb2xsZXIgb3IgVGVzdFJ1biBpbnN0YW5jZS5cbiAgICAgICAgICAgIHZhciBib3VuZFRlc3RSdW4gPSBvcHRpb25zLmJvdW5kVGVzdFJ1bi50ZXN0UnVuIHx8IG9wdGlvbnMuYm91bmRUZXN0UnVuO1xuXG4gICAgICAgICAgICBpZiAoIWJvdW5kVGVzdFJ1blt0ZXN0UnVuTWFya2VyXSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQVBJRXJyb3IodGhpcy5jYWxsc2l0ZU5hbWVzLmluc3RhbnRpYXRpb24sIE1FU1NBR0UuaW52YWxpZENsaWVudEZ1bmN0aW9uVGVzdFJ1bkJpbmRpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChvcHRpb25zLmRlcGVuZGVuY2llcykpXG4gICAgICAgICAgICBhc3NlcnRUeXBlKGlzLm5vbk51bGxPYmplY3QsIHRoaXMuY2FsbHNpdGVOYW1lcy5pbnN0YW50aWF0aW9uLCAnXCJkZXBlbmRlbmNpZXNcIiBvcHRpb24nLCBvcHRpb25zLmRlcGVuZGVuY2llcyk7XG4gICAgfVxuXG4gICAgX2dldFJlcGxpY2F0b3JUcmFuc2Zvcm1zICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG5ldyBGdW5jdGlvblRyYW5zZm9ybSh0aGlzLmNhbGxzaXRlTmFtZXMpXG4gICAgICAgIF07XG4gICAgfVxufVxuIl19
