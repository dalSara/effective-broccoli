'use strict';

exports.__esModule = true;

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _events = require('events');

var _pinkie = require('pinkie');

var _pinkie2 = _interopRequireDefault(_pinkie);

var _timeLimitPromise = require('time-limit-promise');

var _timeLimitPromise2 = _interopRequireDefault(_timeLimitPromise);

var _promisifyEvent = require('promisify-event');

var _promisifyEvent2 = _interopRequireDefault(_promisifyEvent);

var _lodash = require('lodash');

var _mapReverse = require('map-reverse');

var _mapReverse2 = _interopRequireDefault(_mapReverse);

var _runtime = require('../errors/runtime');

var _message = require('../errors/runtime/message');

var _message2 = _interopRequireDefault(_message);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const LOCAL_BROWSERS_READY_TIMEOUT = 2 * 60 * 1000;
const REMOTE_BROWSERS_READY_TIMEOUT = 6 * 60 * 1000;

class BrowserSet extends _events.EventEmitter {
    constructor(browserConnectionGroups) {
        super();

        this.RELEASE_TIMEOUT = 10000;

        this.pendingReleases = [];

        this.browserConnectionGroups = browserConnectionGroups;
        this.browserConnections = (0, _lodash.flatten)(browserConnectionGroups);

        this.connectionsReadyTimeout = null;

        this.browserErrorHandler = error => this.emit('error', error);

        this.browserConnections.forEach(bc => bc.on('error', this.browserErrorHandler));

        // NOTE: We're setting an empty error handler, because Node kills the process on an 'error' event
        // if there is no handler. See: https://nodejs.org/api/events.html#events_class_events_eventemitter
        this.on('error', _lodash.noop);
    }

    static _waitIdle(bc) {
        return (0, _asyncToGenerator3.default)(function* () {
            if (bc.idle || !bc.ready) return;

            yield (0, _promisifyEvent2.default)(bc, 'idle');
        })();
    }

    static _closeConnection(bc) {
        return (0, _asyncToGenerator3.default)(function* () {
            if (bc.closed || !bc.ready) return;

            bc.close();

            yield (0, _promisifyEvent2.default)(bc, 'closed');
        })();
    }

    _getReadyTimeout() {
        var _this = this;

        return (0, _asyncToGenerator3.default)(function* () {
            var isLocalBrowser = function isLocalBrowser(connection) {
                return connection.provider.isLocalBrowser(connection.id, connection.browserInfo.browserName);
            };
            var remoteBrowsersExist = (yield _pinkie2.default.all(_this.browserConnections.map(isLocalBrowser))).indexOf(false) > -1;

            return remoteBrowsersExist ? REMOTE_BROWSERS_READY_TIMEOUT : LOCAL_BROWSERS_READY_TIMEOUT;
        })();
    }

    _createPendingConnectionPromise(readyPromise, timeout, timeoutError) {
        const timeoutPromise = new _pinkie2.default((_, reject) => {
            this.connectionsReadyTimeout = setTimeout(() => reject(timeoutError), timeout);
        });

        return _pinkie2.default.race([readyPromise, timeoutPromise]).then(value => {
            this.connectionsReadyTimeout.unref();
            return value;
        }, error => {
            this.connectionsReadyTimeout.unref();
            throw error;
        });
    }

    _waitConnectionsOpened() {
        var _this2 = this;

        return (0, _asyncToGenerator3.default)(function* () {
            var connectionsReadyPromise = _pinkie2.default.all(_this2.browserConnections.filter(function (bc) {
                return !bc.opened;
            }).map(function (bc) {
                return (0, _promisifyEvent2.default)(bc, 'opened');
            }));

            var timeoutError = new _runtime.GeneralError(_message2.default.cantEstablishBrowserConnection);
            var readyTimeout = yield _this2._getReadyTimeout();

            yield _this2._createPendingConnectionPromise(connectionsReadyPromise, readyTimeout, timeoutError);
        })();
    }

    _checkForDisconnections() {
        var disconnectedUserAgents = this.browserConnections.filter(bc => bc.closed).map(bc => bc.userAgent);

        if (disconnectedUserAgents.length) throw new _runtime.GeneralError(_message2.default.cantRunAgainstDisconnectedBrowsers, disconnectedUserAgents.join(', '));
    }

    //API
    static from(browserConnections) {
        var browserSet = new BrowserSet(browserConnections);

        var prepareConnection = _pinkie2.default.resolve().then(() => {
            browserSet._checkForDisconnections();
            return browserSet._waitConnectionsOpened();
        }).then(() => browserSet);

        return _pinkie2.default.race([prepareConnection, (0, _promisifyEvent2.default)(browserSet, 'error')]).catch((() => {
            var _ref = (0, _asyncToGenerator3.default)(function* (error) {
                yield browserSet.dispose();

                throw error;
            });

            return function (_x) {
                return _ref.apply(this, arguments);
            };
        })());
    }

    releaseConnection(bc) {
        if (this.browserConnections.indexOf(bc) < 0) return _pinkie2.default.resolve();

        (0, _lodash.pull)(this.browserConnections, bc);

        bc.removeListener('error', this.browserErrorHandler);

        var appropriateStateSwitch = !bc.permanent ? BrowserSet._closeConnection(bc) : BrowserSet._waitIdle(bc);

        var release = (0, _timeLimitPromise2.default)(appropriateStateSwitch, this.RELEASE_TIMEOUT).then(() => (0, _lodash.pull)(this.pendingReleases, release));

        this.pendingReleases.push(release);

        return release;
    }

    dispose() {
        var _this3 = this;

        return (0, _asyncToGenerator3.default)(function* () {
            // NOTE: When browserConnection is cancelled, it is removed from
            // the this.connections array, which leads to shifting indexes
            // towards the beginning. So, we must copy the array in order to iterate it,
            // or we can perform iteration from the end to the beginning.
            if (_this3.connectionsReadyTimeout) _this3.connectionsReadyTimeout.unref();

            (0, _mapReverse2.default)(_this3.browserConnections, function (bc) {
                return _this3.releaseConnection(bc);
            });

            yield _pinkie2.default.all(_this3.pendingReleases);
        })();
    }
}
exports.default = BrowserSet;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9ydW5uZXIvYnJvd3Nlci1zZXQuanMiXSwibmFtZXMiOlsiTE9DQUxfQlJPV1NFUlNfUkVBRFlfVElNRU9VVCIsIlJFTU9URV9CUk9XU0VSU19SRUFEWV9USU1FT1VUIiwiQnJvd3NlclNldCIsIkV2ZW50RW1pdHRlciIsImNvbnN0cnVjdG9yIiwiYnJvd3NlckNvbm5lY3Rpb25Hcm91cHMiLCJSRUxFQVNFX1RJTUVPVVQiLCJwZW5kaW5nUmVsZWFzZXMiLCJicm93c2VyQ29ubmVjdGlvbnMiLCJjb25uZWN0aW9uc1JlYWR5VGltZW91dCIsImJyb3dzZXJFcnJvckhhbmRsZXIiLCJlcnJvciIsImVtaXQiLCJmb3JFYWNoIiwiYmMiLCJvbiIsIm5vb3AiLCJfd2FpdElkbGUiLCJpZGxlIiwicmVhZHkiLCJfY2xvc2VDb25uZWN0aW9uIiwiY2xvc2VkIiwiY2xvc2UiLCJfZ2V0UmVhZHlUaW1lb3V0IiwiaXNMb2NhbEJyb3dzZXIiLCJjb25uZWN0aW9uIiwicHJvdmlkZXIiLCJpZCIsImJyb3dzZXJJbmZvIiwiYnJvd3Nlck5hbWUiLCJyZW1vdGVCcm93c2Vyc0V4aXN0IiwiUHJvbWlzZSIsImFsbCIsIm1hcCIsImluZGV4T2YiLCJfY3JlYXRlUGVuZGluZ0Nvbm5lY3Rpb25Qcm9taXNlIiwicmVhZHlQcm9taXNlIiwidGltZW91dCIsInRpbWVvdXRFcnJvciIsInRpbWVvdXRQcm9taXNlIiwiXyIsInJlamVjdCIsInNldFRpbWVvdXQiLCJyYWNlIiwidGhlbiIsInZhbHVlIiwidW5yZWYiLCJfd2FpdENvbm5lY3Rpb25zT3BlbmVkIiwiY29ubmVjdGlvbnNSZWFkeVByb21pc2UiLCJmaWx0ZXIiLCJvcGVuZWQiLCJHZW5lcmFsRXJyb3IiLCJNRVNTQUdFIiwiY2FudEVzdGFibGlzaEJyb3dzZXJDb25uZWN0aW9uIiwicmVhZHlUaW1lb3V0IiwiX2NoZWNrRm9yRGlzY29ubmVjdGlvbnMiLCJkaXNjb25uZWN0ZWRVc2VyQWdlbnRzIiwidXNlckFnZW50IiwibGVuZ3RoIiwiY2FudFJ1bkFnYWluc3REaXNjb25uZWN0ZWRCcm93c2VycyIsImpvaW4iLCJmcm9tIiwiYnJvd3NlclNldCIsInByZXBhcmVDb25uZWN0aW9uIiwicmVzb2x2ZSIsImNhdGNoIiwiZGlzcG9zZSIsInJlbGVhc2VDb25uZWN0aW9uIiwicmVtb3ZlTGlzdGVuZXIiLCJhcHByb3ByaWF0ZVN0YXRlU3dpdGNoIiwicGVybWFuZW50IiwicmVsZWFzZSIsInB1c2giXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7Ozs7O0FBRUEsTUFBTUEsK0JBQWdDLElBQUksRUFBSixHQUFTLElBQS9DO0FBQ0EsTUFBTUMsZ0NBQWdDLElBQUksRUFBSixHQUFTLElBQS9DOztBQUVlLE1BQU1DLFVBQU4sU0FBeUJDLG9CQUF6QixDQUFzQztBQUNqREMsZ0JBQWFDLHVCQUFiLEVBQXNDO0FBQ2xDOztBQUVBLGFBQUtDLGVBQUwsR0FBdUIsS0FBdkI7O0FBRUEsYUFBS0MsZUFBTCxHQUF1QixFQUF2Qjs7QUFFQSxhQUFLRix1QkFBTCxHQUErQkEsdUJBQS9CO0FBQ0EsYUFBS0csa0JBQUwsR0FBK0IscUJBQVFILHVCQUFSLENBQS9COztBQUVBLGFBQUtJLHVCQUFMLEdBQStCLElBQS9COztBQUVBLGFBQUtDLG1CQUFMLEdBQTJCQyxTQUFTLEtBQUtDLElBQUwsQ0FBVSxPQUFWLEVBQW1CRCxLQUFuQixDQUFwQzs7QUFFQSxhQUFLSCxrQkFBTCxDQUF3QkssT0FBeEIsQ0FBZ0NDLE1BQU1BLEdBQUdDLEVBQUgsQ0FBTSxPQUFOLEVBQWUsS0FBS0wsbUJBQXBCLENBQXRDOztBQUVBO0FBQ0E7QUFDQSxhQUFLSyxFQUFMLENBQVEsT0FBUixFQUFpQkMsWUFBakI7QUFDSDs7QUFFRCxXQUFhQyxTQUFiLENBQXdCSCxFQUF4QixFQUE0QjtBQUFBO0FBQ3hCLGdCQUFJQSxHQUFHSSxJQUFILElBQVcsQ0FBQ0os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T0FBS3pELHVCQUFULEVBQ0ksT0FBS0EsdUJBQUwsQ0FBNkJxQyxLQUE3Qjs7QUFFSixzQ0FBVyxPQUFLdEMsa0JBQWhCLEVBQW9DO0FBQUEsdUJBQU0sT0FBSzJELGlCQUFMLENBQXVCckQsRUFBdkIsQ0FBTjtBQUFBLGFBQXBDOztBQUVBLGtCQUFNaUIsaUJBQVFDLEdBQVIsQ0FBWSxPQUFLekIsZUFBakIsQ0FBTjtBQVZhO0FBV2hCO0FBNUlnRDtrQkFBaENMLFUiLCJmaWxlIjoicnVubmVyL2Jyb3dzZXItc2V0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRzJztcbmltcG9ydCBQcm9taXNlIGZyb20gJ3BpbmtpZSc7XG5pbXBvcnQgdGltZUxpbWl0IGZyb20gJ3RpbWUtbGltaXQtcHJvbWlzZSc7XG5pbXBvcnQgcHJvbWlzaWZ5RXZlbnQgZnJvbSAncHJvbWlzaWZ5LWV2ZW50JztcbmltcG9ydCB7IG5vb3AsIHB1bGwgYXMgcmVtb3ZlLCBmbGF0dGVuIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBtYXBSZXZlcnNlIGZyb20gJ21hcC1yZXZlcnNlJztcbmltcG9ydCB7IEdlbmVyYWxFcnJvciB9IGZyb20gJy4uL2Vycm9ycy9ydW50aW1lJztcbmltcG9ydCBNRVNTQUdFIGZyb20gJy4uL2Vycm9ycy9ydW50aW1lL21lc3NhZ2UnO1xuXG5jb25zdCBMT0NBTF9CUk9XU0VSU19SRUFEWV9USU1FT1VUICA9IDIgKiA2MCAqIDEwMDA7XG5jb25zdCBSRU1PVEVfQlJPV1NFUlNfUkVBRFlfVElNRU9VVCA9IDYgKiA2MCAqIDEwMDA7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJyb3dzZXJTZXQgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yIChicm93c2VyQ29ubmVjdGlvbkdyb3Vwcykge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIHRoaXMuUkVMRUFTRV9USU1FT1VUID0gMTAwMDA7XG5cbiAgICAgICAgdGhpcy5wZW5kaW5nUmVsZWFzZXMgPSBbXTtcblxuICAgICAgICB0aGlzLmJyb3dzZXJDb25uZWN0aW9uR3JvdXBzID0gYnJvd3NlckNvbm5lY3Rpb25Hcm91cHM7XG4gICAgICAgIHRoaXMuYnJvd3NlckNvbm5lY3Rpb25zICAgICAgPSBmbGF0dGVuKGJyb3dzZXJDb25uZWN0aW9uR3JvdXBzKTtcblxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25zUmVhZHlUaW1lb3V0ID0gbnVsbDtcblxuICAgICAgICB0aGlzLmJyb3dzZXJFcnJvckhhbmRsZXIgPSBlcnJvciA9PiB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuXG4gICAgICAgIHRoaXMuYnJvd3NlckNvbm5lY3Rpb25zLmZvckVhY2goYmMgPT4gYmMub24oJ2Vycm9yJywgdGhpcy5icm93c2VyRXJyb3JIYW5kbGVyKSk7XG5cbiAgICAgICAgLy8gTk9URTogV2UncmUgc2V0dGluZyBhbiBlbXB0eSBlcnJvciBoYW5kbGVyLCBiZWNhdXNlIE5vZGUga2lsbHMgdGhlIHByb2Nlc3Mgb24gYW4gJ2Vycm9yJyBldmVudFxuICAgICAgICAvLyBpZiB0aGVyZSBpcyBubyBoYW5kbGVyLiBTZWU6IGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvZXZlbnRzLmh0bWwjZXZlbnRzX2NsYXNzX2V2ZW50c19ldmVudGVtaXR0ZXJcbiAgICAgICAgdGhpcy5vbignZXJyb3InLCBub29wKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgYXN5bmMgX3dhaXRJZGxlIChiYykge1xuICAgICAgICBpZiAoYmMuaWRsZSB8fCAhYmMucmVhZHkpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgYXdhaXQgcHJvbWlzaWZ5RXZlbnQoYmMsICdpZGxlJyk7XG4gICAgfVxuXG4gICAgc3RhdGljIGFzeW5jIF9jbG9zZUNvbm5lY3Rpb24gKGJjKSB7XG4gICAgICAgIGlmIChiYy5jbG9zZWQgfHwgIWJjLnJlYWR5KVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIGJjLmNsb3NlKCk7XG5cbiAgICAgICAgYXdhaXQgcHJvbWlzaWZ5RXZlbnQoYmMsICdjbG9zZWQnKTtcbiAgICB9XG5cbiAgICBhc3luYyBfZ2V0UmVhZHlUaW1lb3V0ICgpIHtcbiAgICAgICAgdmFyIGlzTG9jYWxCcm93c2VyICAgICAgPSBjb25uZWN0aW9uID0+IGNvbm5lY3Rpb24ucHJvdmlkZXIuaXNMb2NhbEJyb3dzZXIoY29ubmVjdGlvbi5pZCwgY29ubmVjdGlvbi5icm93c2VySW5mby5icm93c2VyTmFtZSk7XG4gICAgICAgIHZhciByZW1vdGVCcm93c2Vyc0V4aXN0ID0gKGF3YWl0IFByb21pc2UuYWxsKHRoaXMuYnJvd3NlckNvbm5lY3Rpb25zLm1hcChpc0xvY2FsQnJvd3NlcikpKS5pbmRleE9mKGZhbHNlKSA+IC0xO1xuXG4gICAgICAgIHJldHVybiByZW1vdGVCcm93c2Vyc0V4aXN0ID8gUkVNT1RFX0JST1dTRVJTX1JFQURZX1RJTUVPVVQgOiBMT0NBTF9CUk9XU0VSU19SRUFEWV9USU1FT1VUO1xuICAgIH1cblxuICAgIF9jcmVhdGVQZW5kaW5nQ29ubmVjdGlvblByb21pc2UgKHJlYWR5UHJvbWlzZSwgdGltZW91dCwgdGltZW91dEVycm9yKSB7XG4gICAgICAgIGNvbnN0IHRpbWVvdXRQcm9taXNlID0gbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uc1JlYWR5VGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4gcmVqZWN0KHRpbWVvdXRFcnJvciksIHRpbWVvdXQpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gUHJvbWlzZVxuICAgICAgICAgICAgLnJhY2UoW3JlYWR5UHJvbWlzZSwgdGltZW91dFByb21pc2VdKVxuICAgICAgICAgICAgLnRoZW4oXG4gICAgICAgICAgICAgICAgdmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25zUmVhZHlUaW1lb3V0LnVucmVmKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uc1JlYWR5VGltZW91dC51bnJlZigpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgIH1cblxuICAgIGFzeW5jIF93YWl0Q29ubmVjdGlvbnNPcGVuZWQgKCkge1xuICAgICAgICB2YXIgY29ubmVjdGlvbnNSZWFkeVByb21pc2UgPSBQcm9taXNlLmFsbChcbiAgICAgICAgICAgIHRoaXMuYnJvd3NlckNvbm5lY3Rpb25zXG4gICAgICAgICAgICAgICAgLmZpbHRlcihiYyA9PiAhYmMub3BlbmVkKVxuICAgICAgICAgICAgICAgIC5tYXAoYmMgPT4gcHJvbWlzaWZ5RXZlbnQoYmMsICdvcGVuZWQnKSlcbiAgICAgICAgKTtcblxuICAgICAgICB2YXIgdGltZW91dEVycm9yID0gbmV3IEdlbmVyYWxFcnJvcihNRVNTQUdFLmNhbnRFc3RhYmxpc2hCcm93c2VyQ29ubmVjdGlvbik7XG4gICAgICAgIHZhciByZWFkeVRpbWVvdXQgPSBhd2FpdCB0aGlzLl9nZXRSZWFkeVRpbWVvdXQoKTtcblxuICAgICAgICBhd2FpdCB0aGlzLl9jcmVhdGVQZW5kaW5nQ29ubmVjdGlvblByb21pc2UoY29ubmVjdGlvbnNSZWFkeVByb21pc2UsIHJlYWR5VGltZW91dCwgdGltZW91dEVycm9yKTtcbiAgICB9XG5cbiAgICBfY2hlY2tGb3JEaXNjb25uZWN0aW9ucyAoKSB7XG4gICAgICAgIHZhciBkaXNjb25uZWN0ZWRVc2VyQWdlbnRzID0gdGhpcy5icm93c2VyQ29ubmVjdGlvbnNcbiAgICAgICAgICAgIC5maWx0ZXIoYmMgPT4gYmMuY2xvc2VkKVxuICAgICAgICAgICAgLm1hcChiYyA9PiBiYy51c2VyQWdlbnQpO1xuXG4gICAgICAgIGlmIChkaXNjb25uZWN0ZWRVc2VyQWdlbnRzLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBHZW5lcmFsRXJyb3IoTUVTU0FHRS5jYW50UnVuQWdhaW5zdERpc2Nvbm5lY3RlZEJyb3dzZXJzLCBkaXNjb25uZWN0ZWRVc2VyQWdlbnRzLmpvaW4oJywgJykpO1xuICAgIH1cblxuXG4gICAgLy9BUElcbiAgICBzdGF0aWMgZnJvbSAoYnJvd3NlckNvbm5lY3Rpb25zKSB7XG4gICAgICAgIHZhciBicm93c2VyU2V0ID0gbmV3IEJyb3dzZXJTZXQoYnJvd3NlckNvbm5lY3Rpb25zKTtcblxuICAgICAgICB2YXIgcHJlcGFyZUNvbm5lY3Rpb24gPSBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGJyb3dzZXJTZXQuX2NoZWNrRm9yRGlzY29ubmVjdGlvbnMoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYnJvd3NlclNldC5fd2FpdENvbm5lY3Rpb25zT3BlbmVkKCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4gYnJvd3NlclNldCk7XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2VcbiAgICAgICAgICAgIC5yYWNlKFtcbiAgICAgICAgICAgICAgICBwcmVwYXJlQ29ubmVjdGlvbixcbiAgICAgICAgICAgICAgICBwcm9taXNpZnlFdmVudChicm93c2VyU2V0LCAnZXJyb3InKVxuICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIC5jYXRjaChhc3luYyBlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgYXdhaXQgYnJvd3NlclNldC5kaXNwb3NlKCk7XG5cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJlbGVhc2VDb25uZWN0aW9uIChiYykge1xuICAgICAgICBpZiAodGhpcy5icm93c2VyQ29ubmVjdGlvbnMuaW5kZXhPZihiYykgPCAwKVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuXG4gICAgICAgIHJlbW92ZSh0aGlzLmJyb3dzZXJDb25uZWN0aW9ucywgYmMpO1xuXG4gICAgICAgIGJjLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIHRoaXMuYnJvd3NlckVycm9ySGFuZGxlcik7XG5cbiAgICAgICAgdmFyIGFwcHJvcHJpYXRlU3RhdGVTd2l0Y2ggPSAhYmMucGVybWFuZW50ID9cbiAgICAgICAgICAgIEJyb3dzZXJTZXQuX2Nsb3NlQ29ubmVjdGlvbihiYykgOlxuICAgICAgICAgICAgQnJvd3NlclNldC5fd2FpdElkbGUoYmMpO1xuXG4gICAgICAgIHZhciByZWxlYXNlID0gdGltZUxpbWl0KGFwcHJvcHJpYXRlU3RhdGVTd2l0Y2gsIHRoaXMuUkVMRUFTRV9USU1FT1VUKS50aGVuKCgpID0+IHJlbW92ZSh0aGlzLnBlbmRpbmdSZWxlYXNlcywgcmVsZWFzZSkpO1xuXG4gICAgICAgIHRoaXMucGVuZGluZ1JlbGVhc2VzLnB1c2gocmVsZWFzZSk7XG5cbiAgICAgICAgcmV0dXJuIHJlbGVhc2U7XG4gICAgfVxuXG4gICAgYXN5bmMgZGlzcG9zZSAoKSB7XG4gICAgICAgIC8vIE5PVEU6IFdoZW4gYnJvd3NlckNvbm5lY3Rpb24gaXMgY2FuY2VsbGVkLCBpdCBpcyByZW1vdmVkIGZyb21cbiAgICAgICAgLy8gdGhlIHRoaXMuY29ubmVjdGlvbnMgYXJyYXksIHdoaWNoIGxlYWRzIHRvIHNoaWZ0aW5nIGluZGV4ZXNcbiAgICAgICAgLy8gdG93YXJkcyB0aGUgYmVnaW5uaW5nLiBTbywgd2UgbXVzdCBjb3B5IHRoZSBhcnJheSBpbiBvcmRlciB0byBpdGVyYXRlIGl0LFxuICAgICAgICAvLyBvciB3ZSBjYW4gcGVyZm9ybSBpdGVyYXRpb24gZnJvbSB0aGUgZW5kIHRvIHRoZSBiZWdpbm5pbmcuXG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3Rpb25zUmVhZHlUaW1lb3V0KVxuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uc1JlYWR5VGltZW91dC51bnJlZigpO1xuXG4gICAgICAgIG1hcFJldmVyc2UodGhpcy5icm93c2VyQ29ubmVjdGlvbnMsIGJjID0+IHRoaXMucmVsZWFzZUNvbm5lY3Rpb24oYmMpKTtcblxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLnBlbmRpbmdSZWxlYXNlcyk7XG4gICAgfVxufVxuIl19
