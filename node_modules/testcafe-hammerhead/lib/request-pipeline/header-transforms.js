'use strict';

exports.__esModule = true;
exports.forRequest = forRequest;
exports.forResponse = forResponse;
exports.transformHeadersCaseToRaw = transformHeadersCaseToRaw;

var _headers = require('./xhr/headers');

var _headers2 = _interopRequireDefault(_headers);

var _authorization = require('./xhr/authorization');

var _authorization2 = _interopRequireDefault(_authorization);

var _url = require('../utils/url');

var urlUtils = _interopRequireWildcard(_url);

var _url2 = require('url');

var _cookie = require('../utils/cookie');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Skipping transform
function skip() {
    return void 0;
}

function skipIfStateSnapshotIsApplied(src, ctx) {
    return ctx.restoringStorages ? void 0 : src;
}

function isCrossDomainXhrWithoutCredentials(ctx) {
    return ctx.isXhr && !ctx.req.headers[_headers2.default.withCredentials] && ctx.dest.reqOrigin !== ctx.dest.domain;
}

function transformAuthorizationHeader(src, ctx) {
    if (src.includes(_authorization2.default.valuePrefix)) return src.replace(_authorization2.default.valuePrefix, '');

    return isCrossDomainXhrWithoutCredentials(ctx) ? void 0 : src;
}

function transformCookieForFetch(src, ctx) {
    var requestCredentials = ctx.req.headers[_headers2.default.fetchRequestCredentials];

    switch (requestCredentials) {
        case 'omit':
            return void 0;
        case 'same-origin':
            return ctx.dest.reqOrigin === ctx.dest.domain ? src : void 0;
        case 'include':
            return src;
        default:
            return void 0;
    }
}

function transformCookie(src, ctx) {
    if (ctx.isXhr) return isCrossDomainXhrWithoutCredentials(ctx) ? void 0 : src;else if (ctx.isFetch) return transformCookieForFetch(src, ctx);

    return src;
}

function generateServerSyncCookie(ctx, parsedCookies) {
    parsedCookies = parsedCookies.filter(function (cookie) {
        return !cookie.httpOnly;
    });

    var syncWithClientCookies = parsedCookies.map(function (cookie) {
        cookie.isServerSync = true;
        cookie.sid = ctx.session.id;

        return (0, _cookie.formatSyncCookie)(cookie);
    });

    if (ctx.req.headers.cookie) {
        var parsedClientSyncCookie = (0, _cookie.parseClientSyncCookieStr)(ctx.req.headers.cookie);
        var outdatedSyncCookies = parsedClientSyncCookie.actual.filter(function (clientCookie) {
            for (var _iterator = parsedCookies, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
                var _ref;

                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    _i = _iterator.next();
                    if (_i.done) break;
                    _ref = _i.value;
                }

                var serverCookie = _ref;

                if ((0, _cookie.isOutdatedSyncCookie)(clientCookie, serverCookie)) return true;
            }

            return false;
        });

        syncWithClientCookies = parsedClientSyncCookie.outdated.concat(outdatedSyncCookies).map(_cookie.generateDeleteSyncCookieStr).concat(syncWithClientCookies);
    }

    return syncWithClientCookies;
}

function resolveAndGetProxyUrl(url, ctx) {
    url = urlUtils.prepareUrl(url);

    var _parseUrl = (0, _url2.parse)(url),
        host = _parseUrl.host;

    var isCrossDomain = false;

    if (!host) url = (0, _url2.resolve)(ctx.dest.url, url);

    if (ctx.isIframe && ctx.dest.referer) {
        var isCrossDomainLocationBeforeRedirect = !urlUtils.sameOriginCheck(ctx.dest.referer, ctx.dest.url);
        var isCrossDomainLocationAfterRedirect = !urlUtils.sameOriginCheck(ctx.dest.referer, url);

        isCrossDomain = isCrossDomainLocationBeforeRedirect !== isCrossDomainLocationAfterRedirect;
    }

    return ctx.toProxyUrl(url, isCrossDomain, ctx.contentInfo.contentTypeUrlToken);
}

function transformRefreshHeader(src, ctx) {
    return src.replace(/(url=)(.*)$/i, function (match, prefix, url) {
        return prefix + resolveAndGetProxyUrl(url, ctx);
    });
}

// Request headers
var requestTransforms = Object.assign({
    'host': function host(src, ctx) {
        return ctx.dest.host;
    },
    'referer': function referer(src, ctx) {
        return ctx.dest.referer || void 0;
    },
    'origin': function origin(src, ctx) {
        return ctx.dest.reqOrigin || src;
    },
    'content-length': function contentLength(src, ctx) {
        return ctx.reqBody.length;
    },
    'cookie': skip,
    'if-modified-since': skipIfStateSnapshotIsApplied,
    'if-none-match': skipIfStateSnapshotIsApplied,
    [_headers2.default.requestMarker]: skip,
    [_headers2.default.withCredentials]: skip,
    [_headers2.default.origin]: skip,
    [_headers2.default.fetchRequestCredentials]: skip
}, _authorization2.default.headers.reduce(function (obj, header) {
    obj[header] = transformAuthorizationHeader;

    return obj;
}, {}));

var requestForced = {
    'cookie': function cookie(src, ctx) {
        return transformCookie(ctx.session.cookies.getHeader(ctx.dest.url) || void 0, ctx);
    },

    // NOTE: All browsers except Chrome don't send the 'Origin' header in case of the same domain XHR requests.
    // So, if the request is actually cross-domain, we need to force the 'Origin' header to support CORS. (B234325)
    'origin': function origin(src, ctx) {
        var force = (ctx.isXhr || ctx.isFetch) && !src && ctx.dest.domain !== ctx.dest.reqOrigin;

        return force ? ctx.dest.reqOrigin : src;
    }
};

// Response headers
var responseTransforms = {
    'set-cookie': function setCookie(src, ctx) {
        if (src) {
            var parsedCookies = ctx.session.cookies.setByServer(ctx.dest.url, src);

            if (!ctx.isPage || ctx.isIframe) return generateServerSyncCookie(ctx, parsedCookies);
        }

        // NOTE: Delete header.
        return void 0;
    },

    // NOTE: Disable Content Security Policy (see http://en.wikipedia.org/wiki/Content_Security_Policy).
    'content-security-policy': skip,
    'content-security-policy-report-only': skip,
    'x-content-security-policy': skip,
    'x-content-security-policy-report-only': skip,
    'x-webkit-csp': skip,

    // NOTE: Even if we are not able to be authorized, we should prevent showing the native credentials window.
    'www-authenticate': skip,

    // NOTE: We perform CORS checks on our side, so we skip the related headers.
    'access-control-allow-origin': skip,

    // NOTE: Change the transform type if we have an iframe with an image as src,
    // because it was transformed to HTML with the image tag.
    'content-type': function contentType(src, ctx) {
        return ctx.contentInfo.isIframeWithImageSrc ? 'text/html' : src;
    },
    'content-length': function contentLength(src, ctx) {
        return ctx.contentInfo.requireProcessing ? ctx.destResBody.length : src;
    },

    'location': function location(src, ctx) {
        // NOTE: The RFC 1945 standard requires location URLs to be absolute. However, most popular browsers
        // accept relative URLs. We transform relative URLs to absolute to correctly handle this situation.
        if (ctx.contentInfo.isRedirect) return resolveAndGetProxyUrl(src, ctx);

        return src;
    },

    'x-frame-options': function xFrameOptions(src, ctx) {
        var cspHeader = ctx.destRes.headers['content-security-policy'];

        if (cspHeader && cspHeader.includes('frame-ancestors ')) return void 0;

        if (!src.includes('ALLOW-FROM')) return src;

        src = src.replace('ALLOW-FROM', '').trim();

        var isCrossDomain = ctx.isIframe && !urlUtils.sameOriginCheck(ctx.dest.url, src);
        var proxiedUrl = ctx.toProxyUrl(src, isCrossDomain, ctx.contentInfo.contentTypeUrlToken);

        return 'ALLOW-FROM ' + proxiedUrl;
    },

    'sourcemap': skip,

    'referrer-policy': function referrerPolicy() {
        return 'unsafe-url';
    },

    'refresh': function refresh(src, ctx) {
        return transformRefreshHeader(src, ctx);
    },

    'link': function link(src) {
        if (/[;\s]rel=\s*prefetch/i.test(src)) return void 0;

        return src;
    }
};

// Transformation routine
function transformHeaders(srcHeaders, ctx, transformList, forced) {
    var destHeaders = {};

    var applyTransform = function applyTransform(headerName, headers, transforms) {
        var src = headers[headerName];
        var transform = transforms[headerName];
        var dest = transform ? transform(src, ctx) : src;

        if (dest !== void 0) destHeaders[headerName] = dest;
    };

    Object.keys(srcHeaders).forEach(function (headerName) {
        return applyTransform(headerName, srcHeaders, transformList);
    });

    if (forced) Object.keys(forced).forEach(function (headerName) {
        return applyTransform(headerName, destHeaders, forced);
    });

    return destHeaders;
}

// API
function forRequest(ctx) {
    return transformHeaders(ctx.req.headers, ctx, requestTransforms, requestForced);
}

function forResponse(ctx) {
    return transformHeaders(ctx.destRes.headers, ctx, responseTransforms);
}

function transformHeadersCaseToRaw(headers, rawHeaders) {
    var processedHeaders = {};
    var headersNames = Object.keys(headers);

    for (var i = 0; i < rawHeaders.length; i += 2) {
        var rawHeaderName = rawHeaders[i];
        var headerName = rawHeaderName.toLowerCase();
        var headerIndex = headersNames.indexOf(headerName);

        if (headerIndex > -1) {
            processedHeaders[rawHeaderName] = headers[headerName];
            headersNames[headerIndex] = void 0;
        }
    }

    for (var _iterator2 = headersNames, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
        var _ref2;

        if (_isArray2) {
            if (_i2 >= _iterator2.length) break;
            _ref2 = _iterator2[_i2++];
        } else {
            _i2 = _iterator2.next();
            if (_i2.done) break;
            _ref2 = _i2.value;
        }

        var _headerName = _ref2;

        if (_headerName !== void 0) processedHeaders[_headerName] = headers[_headerName];
    }

    return processedHeaders;
}