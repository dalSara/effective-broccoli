'use strict';

exports.__esModule = true;

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _child_process = require('child_process');

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

var _promisifyEvent = require('promisify-event');

var _promisifyEvent2 = _interopRequireDefault(_promisifyEvent);

var _pinkie = require('pinkie');

var _pinkie2 = _interopRequireDefault(_pinkie);

var _promisifiedFunctions = require('../../promisified-functions');

var _commands = require('./commands');

var _commands2 = _interopRequireDefault(_commands);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const WORKER_PATH = require.resolve('./worker');
const WORKER_STDIO_CONFIG = ['ignore', 'pipe', 'pipe', 'ipc'];

const DEBUG_LOGGER = (0, _debug2.default)('testcafe:utils:temp-directory:cleanup-process');

class CleanupProcess {
    constructor() {
        this.worker = null;
        this.initialized = false;
        this.initPromise = _pinkie2.default.resolve(void 0);

        this.messageCounter = 0;

        this.pendingResponses = {};
    }

    _sendMessage(id, msg) {
        return _pinkie2.default.race([(0, _promisifiedFunctions.sendMessageToChildProcess)(this.worker, (0, _extends3.default)({ id }, msg)), (0, _promisifyEvent2.default)(this.worker, 'error')]);
    }

    _onResponse(response) {
        const pendingResponse = this.pendingResponses[response.id];

        if (response.error) {
            if (pendingResponse) pendingResponse.control.reject(response.error);else this.pendingResponses[response.id] = _pinkie2.default.reject(response.error);
        } else if (pendingResponse) pendingResponse.control.resolve();else this.pendingResponses[response.id] = _pinkie2.default.resolve();
    }

    _waitResponse(id) {
        var _this = this;

        return (0, _asyncToGenerator3.default)(function* () {
            if (!_this.pendingResponses[id]) {
                const promiseControl = {};

                _this.pendingResponses[id] = new _pinkie2.default(function (resolve, reject) {
                    (0, _assign2.default)(promiseControl, { resolve, reject });
                });

                _this.pendingResponses[id].control = promiseControl;
            }

            try {
                yield _this.pendingResponses[id];
            } finally {
                delete _this.pendingResponses[id];
            }
        })();
    }

    _waitResponseForMessage(msg) {
        var _this2 = this;

        return (0, _asyncToGenerator3.default)(function* () {
            const currentId = _this2.messageCounter;

            _this2.messageCounter++;

            yield _this2._sendMessage(currentId, msg);
            yield _this2._waitResponse(currentId);
        })();
    }

    _waitProcessExit() {
        return (0, _promisifyEvent2.default)(this.worker, 'exit').then(exitCode => _pinkie2.default.reject(new Error(`Worker process terminated with code ${exitCode}`)));
    }

    _setupWorkerEventHandlers() {
        this.worker.on('message', message => this._onResponse(message));

        this.worker.stdout.on('data', data => DEBUG_LOGGER('Worker process stdout:\n', String(data)));
        this.worker.stderr.on('data', data => DEBUG_LOGGER('Worker process stderr:\n', String(data)));
    }

    _unrefWorkerProcess() {
        this.worker.unref();
        this.worker.stdout.unref();
        this.worker.stderr.unref();

        const channel = this.worker.channel || this.worker._channel;

        channel.unref();
    }

    _handleProcessError(error) {
        this.initialized = false;

        DEBUG_LOGGER(error);
    }

    init() {
        var _this3 = this;

        this.initPromise = this.initPromise.then((() => {
            var _ref = (0, _asyncToGenerator3.default)(function* (initialized) {
                if (initialized !== void 0) return initialized;

                _this3.worker = (0, _child_process.spawn)(process.argv[0], [WORKER_PATH], { detached: true, stdio: WORKER_STDIO_CONFIG });

                _this3._setupWorkerEventHandlers();
                _this3._unrefWorkerProcess();

                const exitPromise = _this3._waitProcessExit();

                try {
                    yield _pinkie2.default.race([_this3._waitResponseForMessage({ command: _commands2.default.init }), (0, _promisifyEvent2.default)(_this3.worker, 'error'), exitPromise]);

                    _this3.initialized = true;

                    exitPromise.catch(function (error) {
                        return _this3._handleProcessError(error);
                    });

                    _this3.worker.on('error', function (error) {
                        return _this3._handleProcessError(error);
                    });
                } catch (e) {
                    DEBUG_LOGGER('Failed to start cleanup process');
                    DEBUG_LOGGER(e);

                    _this3.initialized = false;
                }

                return _this3.initialized;
            });

            return function (_x) {
                return _ref.apply(this, arguments);
            };
        })());

        return this.initPromise;
    }

    addDirectory(path) {
        var _this4 = this;

        return (0, _asyncToGenerator3.default)(function* () {
            if (!_this4.initialized) return;

            try {
                yield _this4._waitResponseForMessage({ command: _commands2.default.add, path });
            } catch (e) {
                DEBUG_LOGGER(`Failed to add the ${path} directory to cleanup process`);
                DEBUG_LOGGER(e);
            }
        })();
    }

    removeDirectory(path) {
        var _this5 = this;

        return (0, _asyncToGenerator3.default)(function* () {
            if (!_this5.initialized) return;

            try {
                yield _this5._waitResponseForMessage({ command: _commands2.default.remove, path });
            } catch (e) {
                DEBUG_LOGGER(`Failed to remove the ${path} directory in cleanup process`);
                DEBUG_LOGGER(e);
            }
        })();
    }
}

exports.default = new CleanupProcess();
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy91dGlscy90ZW1wLWRpcmVjdG9yeS9jbGVhbnVwLXByb2Nlc3MvaW5kZXguanMiXSwibmFtZXMiOlsiV09SS0VSX1BBVEgiLCJyZXF1aXJlIiwicmVzb2x2ZSIsIldPUktFUl9TVERJT19DT05GSUciLCJERUJVR19MT0dHRVIiLCJDbGVhbnVwUHJvY2VzcyIsImNvbnN0cnVjdG9yIiwid29ya2VyIiwiaW5pdGlhbGl6ZWQiLCJpbml0UHJvbWlzZSIsIlByb21pc2UiLCJtZXNzYWdlQ291bnRlciIsInBlbmRpbmdSZXNwb25zZXMiLCJfc2VuZE1lc3NhZ2UiLCJpZCIsIm1zZyIsInJhY2UiLCJfb25SZXNwb25zZSIsInJlc3BvbnNlIiwicGVuZGluZ1Jlc3BvbnNlIiwiZXJyb3IiLCJjb250cm9sIiwicmVqZWN0IiwiX3dhaXRSZXNwb25zZSIsInByb21pc2VDb250cm9sIiwiX3dhaXRSZXNwb25zZUZvck1lc3NhZ2UiLCJjdXJyZW50SWQiLCJfd2FpdFByb2Nlc3NFeGl0IiwidGhlbiIsImV4aXRDb2RlIiwiRXJyb3IiLCJfc2V0dXBXb3JrZXJFdmVudEhhbmRsZXJzIiwib24iLCJtZXNzYWdlIiwic3Rkb3V0IiwiZGF0YSIsIlN0cmluZyIsInN0ZGVyciIsIl91bnJlZldvcmtlclByb2Nlc3MiLCJ1bnJlZiIsImNoYW5uZWwiLCJfY2hhbm5lbCIsIl9oYW5kbGVQcm9jZXNzRXJyb3IiLCJpbml0IiwicHJvY2VzcyIsImFyZ3YiLCJkZXRhY2hlZCIsInN0ZGlvIiwiZXhpdFByb21pc2UiLCJjb21tYW5kIiwiQ09NTUFORFMiLCJjYXRjaCIsImUiLCJhZGREaXJlY3RvcnkiLCJwYXRoIiwiYWRkIiwicmVtb3ZlRGlyZWN0b3J5IiwicmVtb3ZlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7Ozs7OztBQUdBLE1BQU1BLGNBQXNCQyxRQUFRQyxPQUFS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QTtBQUN6QixnQkFBSSxDQUFDLE9BQUs5QyxXQUFWLEVBQ0k7O0FBRUosZ0JBQUk7QUFDQSxzQkFBTSxPQUFLaUIsdUJBQUwsQ0FBNkIsRUFBRXdCLFNBQVNDLG1CQUFTTyxNQUFwQixFQUE0QkgsSUFBNUIsRUFBN0IsQ0FBTjtBQUNILGFBRkQsQ0FHQSxPQUFPRixDQUFQLEVBQVU7QUFDTmhELDZCQUFjLHdCQUF1QmtELElBQUssK0JBQTFDO0FBQ0FsRCw2QkFBYWdELENBQWI7QUFDSDtBQVZ3QjtBQVc1QjtBQXhKZ0I7O2tCQTJKTixJQUFJL0MsY0FBSixFIiwiZmlsZSI6InV0aWxzL3RlbXAtZGlyZWN0b3J5L2NsZWFudXAtcHJvY2Vzcy9pbmRleC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHNwYXduIH0gZnJvbSAnY2hpbGRfcHJvY2Vzcyc7XG5pbXBvcnQgZGVidWcgZnJvbSAnZGVidWcnO1xuaW1wb3J0IHByb21pc2lmeUV2ZW50IGZyb20gJ3Byb21pc2lmeS1ldmVudCc7XG5pbXBvcnQgUHJvbWlzZSBmcm9tICdwaW5raWUnO1xuaW1wb3J0IHsgc2VuZE1lc3NhZ2VUb0NoaWxkUHJvY2VzcyB9IGZyb20gJy4uLy4uL3Byb21pc2lmaWVkLWZ1bmN0aW9ucyc7XG5pbXBvcnQgQ09NTUFORFMgZnJvbSAnLi9jb21tYW5kcyc7XG5cblxuY29uc3QgV09SS0VSX1BBVEggICAgICAgICA9IHJlcXVpcmUucmVzb2x2ZSgnLi93b3JrZXInKTtcbmNvbnN0IFdPUktFUl9TVERJT19DT05GSUcgPSBbJ2lnbm9yZScsICdwaXBlJywgJ3BpcGUnLCAnaXBjJ107XG5cbmNvbnN0IERFQlVHX0xPR0dFUiA9IGRlYnVnKCd0ZXN0Y2FmZTp1dGlsczp0ZW1wLWRpcmVjdG9yeTpjbGVhbnVwLXByb2Nlc3MnKTtcblxuY2xhc3MgQ2xlYW51cFByb2Nlc3Mge1xuICAgIGNvbnN0cnVjdG9yICgpIHtcbiAgICAgICAgdGhpcy53b3JrZXIgICAgICA9IG51bGw7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pbml0UHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSh2b2lkIDApO1xuXG4gICAgICAgIHRoaXMubWVzc2FnZUNvdW50ZXIgPSAwO1xuXG4gICAgICAgIHRoaXMucGVuZGluZ1Jlc3BvbnNlcyA9IHt9O1xuICAgIH1cblxuICAgIF9zZW5kTWVzc2FnZSAoaWQsIG1zZykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgICAgIHNlbmRNZXNzYWdlVG9DaGlsZFByb2Nlc3ModGhpcy53b3JrZXIsIHsgaWQsIC4uLm1zZyB9KSxcbiAgICAgICAgICAgIHByb21pc2lmeUV2ZW50KHRoaXMud29ya2VyLCAnZXJyb3InKVxuICAgICAgICBdKTtcbiAgICB9XG5cbiAgICBfb25SZXNwb25zZSAocmVzcG9uc2UpIHtcbiAgICAgICAgY29uc3QgcGVuZGluZ1Jlc3BvbnNlID0gdGhpcy5wZW5kaW5nUmVzcG9uc2VzW3Jlc3BvbnNlLmlkXTtcblxuICAgICAgICBpZiAocmVzcG9uc2UuZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChwZW5kaW5nUmVzcG9uc2UpXG4gICAgICAgICAgICAgICAgcGVuZGluZ1Jlc3BvbnNlLmNvbnRyb2wucmVqZWN0KHJlc3BvbnNlLmVycm9yKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdSZXNwb25zZXNbcmVzcG9uc2UuaWRdID0gUHJvbWlzZS5yZWplY3QocmVzcG9uc2UuZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBlbmRpbmdSZXNwb25zZSlcbiAgICAgICAgICAgIHBlbmRpbmdSZXNwb25zZS5jb250cm9sLnJlc29sdmUoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5wZW5kaW5nUmVzcG9uc2VzW3Jlc3BvbnNlLmlkXSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cblxuICAgIGFzeW5jIF93YWl0UmVzcG9uc2UgKGlkKSB7XG4gICAgICAgIGlmICghdGhpcy5wZW5kaW5nUmVzcG9uc2VzW2lkXSkge1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZUNvbnRyb2wgPSB7fTtcblxuICAgICAgICAgICAgdGhpcy5wZW5kaW5nUmVzcG9uc2VzW2lkXSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHByb21pc2VDb250cm9sLCB7IHJlc29sdmUsIHJlamVjdCB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdSZXNwb25zZXNbaWRdLmNvbnRyb2wgPSBwcm9taXNlQ29udHJvbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnBlbmRpbmdSZXNwb25zZXNbaWRdO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMucGVuZGluZ1Jlc3BvbnNlc1tpZF07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBfd2FpdFJlc3BvbnNlRm9yTWVzc2FnZSAobXNnKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRJZCA9IHRoaXMubWVzc2FnZUNvdW50ZXI7XG5cbiAgICAgICAgdGhpcy5tZXNzYWdlQ291bnRlcisrO1xuXG4gICAgICAgIGF3YWl0IHRoaXMuX3NlbmRNZXNzYWdlKGN1cnJlbnRJZCwgbXNnKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fd2FpdFJlc3BvbnNlKGN1cnJlbnRJZCk7XG4gICAgfVxuXG4gICAgX3dhaXRQcm9jZXNzRXhpdCAoKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNpZnlFdmVudCh0aGlzLndvcmtlciwgJ2V4aXQnKVxuICAgICAgICAgICAgLnRoZW4oZXhpdENvZGUgPT4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGBXb3JrZXIgcHJvY2VzcyB0ZXJtaW5hdGVkIHdpdGggY29kZSAke2V4aXRDb2RlfWApKSk7XG4gICAgfVxuXG4gICAgX3NldHVwV29ya2VyRXZlbnRIYW5kbGVycyAoKSB7XG4gICAgICAgIHRoaXMud29ya2VyLm9uKCdtZXNzYWdlJywgbWVzc2FnZSA9PiB0aGlzLl9vblJlc3BvbnNlKG1lc3NhZ2UpKTtcblxuICAgICAgICB0aGlzLndvcmtlci5zdGRvdXQub24oJ2RhdGEnLCBkYXRhID0+IERFQlVHX0xPR0dFUignV29ya2VyIHByb2Nlc3Mgc3Rkb3V0OlxcbicsIFN0cmluZyhkYXRhKSkpO1xuICAgICAgICB0aGlzLndvcmtlci5zdGRlcnIub24oJ2RhdGEnLCBkYXRhID0+IERFQlVHX0xPR0dFUignV29ya2VyIHByb2Nlc3Mgc3RkZXJyOlxcbicsIFN0cmluZyhkYXRhKSkpO1xuICAgIH1cblxuICAgIF91bnJlZldvcmtlclByb2Nlc3MgKCkge1xuICAgICAgICB0aGlzLndvcmtlci51bnJlZigpO1xuICAgICAgICB0aGlzLndvcmtlci5zdGRvdXQudW5yZWYoKTtcbiAgICAgICAgdGhpcy53b3JrZXIuc3RkZXJyLnVucmVmKCk7XG5cbiAgICAgICAgY29uc3QgY2hhbm5lbCA9IHRoaXMud29ya2VyLmNoYW5uZWwgfHwgdGhpcy53b3JrZXIuX2NoYW5uZWw7XG5cbiAgICAgICAgY2hhbm5lbC51bnJlZigpO1xuICAgIH1cblxuICAgIF9oYW5kbGVQcm9jZXNzRXJyb3IgKGVycm9yKSB7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuICAgICAgICBERUJVR19MT0dHRVIoZXJyb3IpO1xuICAgIH1cblxuICAgIGluaXQgKCkge1xuICAgICAgICB0aGlzLmluaXRQcm9taXNlID0gdGhpcy5pbml0UHJvbWlzZVxuICAgICAgICAgICAgLnRoZW4oYXN5bmMgaW5pdGlhbGl6ZWQgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpbml0aWFsaXplZCAhPT0gdm9pZCAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5pdGlhbGl6ZWQ7XG5cbiAgICAgICAgICAgICAgICB0aGlzLndvcmtlciA9IHNwYXduKHByb2Nlc3MuYXJndlswXSwgW1dPUktFUl9QQVRIXSwgeyBkZXRhY2hlZDogdHJ1ZSwgc3RkaW86IFdPUktFUl9TVERJT19DT05GSUcgfSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9zZXR1cFdvcmtlckV2ZW50SGFuZGxlcnMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl91bnJlZldvcmtlclByb2Nlc3MoKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGV4aXRQcm9taXNlID0gdGhpcy5fd2FpdFByb2Nlc3NFeGl0KCk7XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLnJhY2UoW1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fd2FpdFJlc3BvbnNlRm9yTWVzc2FnZSh7IGNvbW1hbmQ6IENPTU1BTkRTLmluaXQgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNpZnlFdmVudCh0aGlzLndvcmtlciwgJ2Vycm9yJyksXG4gICAgICAgICAgICAgICAgICAgICAgICBleGl0UHJvbWlzZVxuICAgICAgICAgICAgICAgICAgICBdKTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICBleGl0UHJvbWlzZS5jYXRjaChlcnJvciA9PiB0aGlzLl9oYW5kbGVQcm9jZXNzRXJyb3IoZXJyb3IpKTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLndvcmtlci5vbignZXJyb3InLCBlcnJvciA9PiB0aGlzLl9oYW5kbGVQcm9jZXNzRXJyb3IoZXJyb3IpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgREVCVUdfTE9HR0VSKCdGYWlsZWQgdG8gc3RhcnQgY2xlYW51cCBwcm9jZXNzJyk7XG4gICAgICAgICAgICAgICAgICAgIERFQlVHX0xPR0dFUihlKTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5pdGlhbGl6ZWQ7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcy5pbml0UHJvbWlzZTtcbiAgICB9XG5cbiAgICBhc3luYyBhZGREaXJlY3RvcnkgKHBhdGgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl93YWl0UmVzcG9uc2VGb3JNZXNzYWdlKHsgY29tbWFuZDogQ09NTUFORFMuYWRkLCBwYXRoIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBERUJVR19MT0dHRVIoYEZhaWxlZCB0byBhZGQgdGhlICR7cGF0aH0gZGlyZWN0b3J5IHRvIGNsZWFudXAgcHJvY2Vzc2ApO1xuICAgICAgICAgICAgREVCVUdfTE9HR0VSKGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgcmVtb3ZlRGlyZWN0b3J5IChwYXRoKSB7XG4gICAgICAgIGlmICghdGhpcy5pbml0aWFsaXplZClcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fd2FpdFJlc3BvbnNlRm9yTWVzc2FnZSh7IGNvbW1hbmQ6IENPTU1BTkRTLnJlbW92ZSwgcGF0aCB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgREVCVUdfTE9HR0VSKGBGYWlsZWQgdG8gcmVtb3ZlIHRoZSAke3BhdGh9IGRpcmVjdG9yeSBpbiBjbGVhbnVwIHByb2Nlc3NgKTtcbiAgICAgICAgICAgIERFQlVHX0xPR0dFUihlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgbmV3IENsZWFudXBQcm9jZXNzKCk7XG4iXX0=
