'use strict';

exports.__esModule = true;
exports.getTypeScriptTestListFromCode = exports.getTypeScriptTestList = undefined;

var _typescript = require('typescript');

var _typescript2 = _interopRequireDefault(_typescript);

var _lodash = require('lodash');

var _compiler = require('./compiler');

var _compiler2 = _interopRequireDefault(_compiler);

var _testFileParserBase = require('../../test-file-parser-base');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function replaceComments(code) {
    return code.replace(/\/\*[\s\S]*?\*\/|([^\\:]|^)\/\/.*$/gm, match => {
        const lastSymbol = match.indexOf('\n') > -1 ? '\n' : ' ';

        return (0, _lodash.repeat)(' ', match.length + lastSymbol);
    });
}

class TypeScriptTestFileParser extends _testFileParserBase.TestFileParserBase {
    constructor() {
        super(_typescript2.default.SyntaxKind);
    }

    getComputedNameString({ pos, end }) {
        const templatePos = this.getLocationByOffsets(pos, end);

        return _testFileParserBase.TestFileParserBase.formatComputedName(templatePos.loc.start.line);
    }

    getTokenType(token) {
        return token.kind;
    }

    getCalleeToken(token) {
        return token.expression;
    }

    getMemberFnName(token) {
        return token.expression.name.text;
    }

    getKeyValue(prop) {
        const name = prop.name,
              initializer = prop.initializer;


        return {
            key: name.text,
            value: this.getStringValue(initializer)
        };
    }

    getFixedStartOffset(start) {
        let fixedStartOffset = start;

        while (/\s/.test(this.codeWithoutComments[fixedStartOffset])) ++fixedStartOffset;

        return fixedStartOffset;
    }

    getLocationByOffsets(start, end) {
        const fixedStart = this.getFixedStartOffset(start);
        const codeArr = this.codeArr;
        const loc = { start: null, end: null };

        let line = codeArr[0];
        let startTmp = fixedStart;
        let endTmp = end;

        for (let lineNumber = 1; lineNumber <= codeArr.length; ++lineNumber, line = codeArr[lineNumber - 1]) {
            startTmp -= line.length + 1;
            endTmp -= line.length + 1;

            if (startTmp < 0 && !loc.start) loc.start = { line: lineNumber, column: line.length + startTmp + 1 };

            if (endTmp <= 0 || lineNumber === codeArr.length - 1) {
                loc.end = { line: lineNumber, column: line.length + endTmp + 1 };

                break;
            }
        }

        return { loc, start: fixedStart, end };
    }

    getRValue(token) {
        return token.initializer;
    }

    getStringValue(token) {
        const stringTypes = [this.tokenType.StringLiteral, this.tokenType.TemplateExpression];

        if (stringTypes.indexOf(token.kind) > -1 || token.text && token.kind !== this.tokenType.NumericLiteral) return this.formatFnArg(token);

        return null;
    }

    isAsyncFn(token) {
        const isGeneratorFn = !!token.asteriskToken;
        const isAsyncFn = token.modifiers && token.modifiers.some(modifier => modifier.kind === this.tokenType.AsyncKeyword);

        return isGeneratorFn || isAsyncFn;
    }

    getFunctionBody(token) {
        return token.body.statements;
    }

    formatFnData(name, value, token, meta = [{}]) {
        const loc = this.getLocationByOffsets(token.pos, token.end);

        return {
            fnName: name,
            value: value,
            loc: loc.loc,
            start: loc.start,
            end: loc.end,
            meta: (0, _lodash.merge)({}, ...meta)
        };
    }

    analyzeMemberExp(token) {
        let exp = token;
        const tokenType = this.tokenType;
        const callStack = [exp];

        while (exp.kind !== this.tokenType.Identifier) {
            exp = exp.expression || exp.tag;

            callStack.push(exp);
        }

        const meta = this.getMetaInfo(callStack.slice());

        if (exp && this.isApiFn(exp.text)) {
            let parentExp = callStack.pop();

            while (parentExp) {
                if (parentExp.kind === tokenType.CallExpression && parentExp.expression) {
                    const calleeType = parentExp.expression.kind;
                    const calleeMemberFn = calleeType === tokenType.PropertyAccessExpression && parentExp.expression.name.text;

                    if (this.checkExpDefineTargetName(calleeType, calleeMemberFn)) return this.formatFnData(exp.text, this.formatFnArg(parentExp.arguments[0]), token, meta);
                }

                if (parentExp.kind === tokenType.TaggedTemplateExpression && parentExp.tag) {
                    const tagType = parentExp.tag.kind;
                    const tagMemberFn = tagType === tokenType.PropertyAccessExpression && parentExp.tag.name.text;

                    if (this.checkExpDefineTargetName(tagType, tagMemberFn)) return this.formatFnData(exp.text, this.formatFnArg(parentExp), token, meta);
                }

                parentExp = callStack.pop();
            }
        }

        return null;
    }

    formatFnArg(arg) {
        if (arg.templateSpans) return this.getComputedNameString({ pos: arg.pos, end: arg.end });

        if (arg.head) return this.getComputedNameString({ pos: arg.template.pos, end: arg.template.end });

        if (arg.template) return arg.template.text || this.getComputedNameString({ pos: arg.template.pos, end: arg.template.end });

        if (arg.kind === this.tokenType.Identifier) return this.getComputedNameString({ pos: arg.pos, end: arg.end });

        if (arg.text && arg.kind !== this.tokenType.NumericLiteral) return arg.text;

        if (arg.kind === this.tokenType.TypeAssertionExpression) return this.formatFnArg(arg.expression);

        return null;
    }

    getFnCall(token) {
        if (this.isApiFn(token.expression.text)) return this.formatFnData(token.expression.text, this.formatFnArg(token.arguments[0]), token);

        return null;
    }

    getTaggedTemplateExp(token) {
        if (this.isApiFn(token.tag.text)) return this.formatFnData(token.tag.text, this.formatFnArg(token), token);

        return null;
    }

    analyzeFnCall(token) {
        const tokenType = this.tokenType;

        if (token.kind === tokenType.PropertyAccessExpression) return this.analyzeMemberExp(token);

        if (token.kind === tokenType.CallExpression) {
            const expKind = token.expression.kind;

            if (expKind === tokenType.PropertyAccessExpression || expKind === tokenType.CallExpression) return this.analyzeMemberExp(token);

            if (expKind === tokenType.ParenthesizedExpression) return this.analyzeFnCall(token.expression.expression);

            return this.getFnCall(token);
        }

        if (token.kind === tokenType.FunctionExpression || token.kind === tokenType.ArrowFunction) return this.collectTestCafeCalls(this.getFunctionBody(token));

        if (token.kind === tokenType.TaggedTemplateExpression) {
            if (token.tag.kind === tokenType.PropertyAccessExpression || token.tag.kind === tokenType.CallExpression) return this.analyzeMemberExp(token);

            return this.getTaggedTemplateExp(token);
        }

        return null;
    }

    parse(code) {
        //NOTE: TypeScript calculates start position of a token incorrectly
        //It doesn't consider spaces and comments between the last token and the current token.
        //So we replace comments with space symbols to calculate fixed position.
        //We just increment position until we meet non whitespace characters
        this.codeArr = code.split('\n');
        this.codeWithoutComments = replaceComments(code);

        const sourceFile = _typescript2.default.createSourceFile('', code, _compiler2.default._getTypescriptOptions(), true);

        return this.analyze(sourceFile.statements);
    }
}

const parser = new TypeScriptTestFileParser();

const getTypeScriptTestList = exports.getTypeScriptTestList = parser.getTestList.bind(parser);
const getTypeScriptTestListFromCode = exports.getTypeScriptTestListFromCode = parser.getTestListFromCode.bind(parser);
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9jb21waWxlci90ZXN0LWZpbGUvZm9ybWF0cy90eXBlc2NyaXB0L2dldC10ZXN0LWxpc3QuanMiXSwibmFtZXMiOlsicmVwbGFjZUNvbW1lbnRzIiwiY29kZSIsInJlcGxhY2UiLCJtYXRjaCIsImxhc3RTeW1ib2wiLCJpbmRleE9mIiwibGVuZ3RoIiwiVHlwZVNjcmlwdFRlc3RGaWxlUGFyc2VyIiwiVGVzdEZpbGVQYXJzZXJCYXNlIiwiY29uc3RydWN0b3IiLCJ0cyIsIlN5bnRheEtpbmQiLCJnZXRDb21wdXRlZE5hbWVTdHJpbmciLCJwb3MiLCJlbmQiLCJ0ZW1wbGF0ZVBvcyIsImdldExvY2F0aW9uQnlPZmZzZXRzIiwiZm9ybWF0Q29tcHV0ZWROYW1lIiwibG9jIiwic3RhcnQiLCJsaW5lIiwiZ2V0VG9rZW5UeXBlIiwidG9rZW4iLCJraW5kIiwiZ2V0Q2FsbGVlVG9rZW4iLCJleHByZXNzaW9uIiwiZ2V0TWVtYmVyRm5OYW1lIiwibmFtZSIsInRleHQiLCJnZXRLZXlWYWx1ZSIsInByb3AiLCJpbml0aWFsaXplciIsImtleSIsInZhbHVlIiwiZ2V0U3RyaW5nVmFsdWUiLCJnZXRGaXhlZFN0YXJ0T2Zmc2V0IiwiZml4ZWRTdGFydE9mZnNldCIsInRlc3QiLCJjb2RlV2l0aG91dENvbW1lbnRzIiwiZml4ZWRTdGFydCIsImNvZGVBcnIiLCJzdGFydFRtcCIsImVuZFRtcCIsImxpbmVOdW1iZXIiLCJjb2x1bW4iLCJnZXRSVmFsdWUiLCJzdHJpbmdUeXBlcyIsInRva2VuVHlwZSIsIlN0cmluZ0xpdGVyYWwiLCJUZW1wbGF0ZUV4cHJlc3Npb24iLCJOdW1lcmljTGl0ZXJhbCIsImZvcm1hdEZuQXJnIiwiaXNBc3luY0ZuIiwiaXNHZW5lcmF0b3JGbiIsImFzdGVyaXNrVG9rZW4iLCJtb2RpZmllcnMiLCJzb21lIiwibW9kaWZpZXIiLCJBc3luY0tleXdvcmQiLCJnZXRGdW5jdGlvbkJvZHkiLCJib2R5Iiwic3RhdGVtZW50cyIsImZvcm1hdEZuRGF0YSIsIm1ldGEiLCJmbk5hbWUiLCJhbmFseXplTWVtYmVyRXhwIiwiZXhwIiwiY2FsbFN0YWNrIiwiSWRlbnRpZmllciIsInRhZyIsInB1c2giLCJnZXRNZXRhSW5mbyIsInNsaWNlIiwiaXNBcGlGbiIsInBhcmVudEV4cCIsInBvcCIsIkNhbGxFeHByZXNzaW9uIiwiY2FsbGVlVHlwZSIsImNhbGxlZU1lbWJlckZuIiwiUHJvcGVydHlBY2Nlc3NFeHByZXNzaW9uIiwiY2hlY2tFeHBEZWZpbmVUYXJnZXROYW1lIiwiYXJndW1lbnRzIiwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uIiwidGFnVHlwZSIsInRhZ01lbWJlckZuIiwiYXJnIiwidGVtcGxhdGVTcGFucyIsImhlYWQiLCJ0ZW1wbGF0ZSIsIlR5cGVBc3NlcnRpb25FeHByZXNzaW9uIiwiZ2V0Rm5DYWxsIiwiZ2V0VGFnZ2VkVGVtcGxhdGVFeHAiLCJhbmFseXplRm5DYWxsIiwiZXhwS2luZCIsIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uIiwiRnVuY3Rpb25FeHByZXNzaW9uIiwiQXJyb3dGdW5jdGlvbiIsImNvbGxlY3RUZXN0Q2FmZUNhbGxzIiwicGFyc2UiLCJzcGxpdCIsInNvdXJjZUZpbGUiLCJjcmVhdGVTb3VyY2VGaWxlIiwiVHlwZVNjcmlwdFRlc3RGaWxlQ29tcGlsZXIiLCJfZ2V0VHlwZXNjcmlwdE9wdGlvbnMiLCJhbmFseXplIiwicGFyc2VyIiwiZ2V0VHlwZVNjcmlwdFRlc3RMaXN0IiwiZ2V0VGVzdExpc3QiLCJiaW5kIiwiZ2V0VHlwZVNjcmlwdFRlc3RMaXN0RnJvbUNvZGUiLCJnZXRUZXN0TGlzdEZyb21Db2RlIl0sIm1hcHBpbmdzIjoiOzs7OztBQUFBOzs7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7OztBQUVBLFNBQVNBLGVBQVQsQ0FBMEJDLElBQTFCLEVBQWdDO0FBQzVCLFdBQU9BLEtBQUtDLE9BQUwsQ0FBYSxzQ0FBYixFQUFxREMsU0FBUztBQUNqRSxjQUFNQyxhQUFhRCxNQUFNRSxP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QUwsR0FBMkJ0QyxnQkFBZ0JDLElBQWhCLENBQTNCOztBQUVBLGNBQU1tRyxhQUFhMUYscUJBQUcyRixnQkFBSCxDQUFvQixFQUFwQixFQUF3QnBHLElBQXhCLEVBQThCcUcsbUJBQTJCQyxxQkFBM0IsRUFBOUIsRUFBa0YsSUFBbEYsQ0FBbkI7O0FBRUEsZUFBTyxLQUFLQyxPQUFMLENBQWFKLFdBQVd2QyxVQUF4QixDQUFQO0FBQ0g7QUFoT3FEOztBQW1PMUQsTUFBTTRDLFNBQVMsSUFBSWxHLHdCQUFKLEVBQWY7O0FBRU8sTUFBTW1HLHdEQUFnQ0QsT0FBT0UsV0FBUCxDQUFtQkMsSUFBbkIsQ0FBd0JILE1BQXhCLENBQXRDO0FBQ0EsTUFBTUksd0VBQWdDSixPQUFPSyxtQkFBUCxDQUEyQkYsSUFBM0IsQ0FBZ0NILE1BQWhDLENBQXRDIiwiZmlsZSI6ImNvbXBpbGVyL3Rlc3QtZmlsZS9mb3JtYXRzL3R5cGVzY3JpcHQvZ2V0LXRlc3QtbGlzdC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0cyBmcm9tICd0eXBlc2NyaXB0JztcbmltcG9ydCB7IHJlcGVhdCwgbWVyZ2UgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IFR5cGVTY3JpcHRUZXN0RmlsZUNvbXBpbGVyIGZyb20gJy4vY29tcGlsZXInO1xuaW1wb3J0IHsgVGVzdEZpbGVQYXJzZXJCYXNlIH0gZnJvbSAnLi4vLi4vdGVzdC1maWxlLXBhcnNlci1iYXNlJztcblxuZnVuY3Rpb24gcmVwbGFjZUNvbW1lbnRzIChjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUucmVwbGFjZSgvXFwvXFwqW1xcc1xcU10qP1xcKlxcL3woW15cXFxcOl18XilcXC9cXC8uKiQvZ20sIG1hdGNoID0+IHtcbiAgICAgICAgY29uc3QgbGFzdFN5bWJvbCA9IG1hdGNoLmluZGV4T2YoJ1xcbicpID4gLTEgPyAnXFxuJyA6ICcgJztcblxuICAgICAgICByZXR1cm4gcmVwZWF0KCcgJywgbWF0Y2gubGVuZ3RoICsgbGFzdFN5bWJvbCk7XG4gICAgfSk7XG59XG5cbmNsYXNzIFR5cGVTY3JpcHRUZXN0RmlsZVBhcnNlciBleHRlbmRzIFRlc3RGaWxlUGFyc2VyQmFzZSB7XG4gICAgY29uc3RydWN0b3IgKCkge1xuICAgICAgICBzdXBlcih0cy5TeW50YXhLaW5kKTtcbiAgICB9XG5cbiAgICBnZXRDb21wdXRlZE5hbWVTdHJpbmcgKHsgcG9zLCBlbmQgfSkge1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZVBvcyA9IHRoaXMuZ2V0TG9jYXRpb25CeU9mZnNldHMocG9zLCBlbmQpO1xuXG4gICAgICAgIHJldHVybiBUZXN0RmlsZVBhcnNlckJhc2UuZm9ybWF0Q29tcHV0ZWROYW1lKHRlbXBsYXRlUG9zLmxvYy5zdGFydC5saW5lKTtcbiAgICB9XG5cbiAgICBnZXRUb2tlblR5cGUgKHRva2VuKSB7XG4gICAgICAgIHJldHVybiB0b2tlbi5raW5kO1xuICAgIH1cblxuICAgIGdldENhbGxlZVRva2VuICh0b2tlbikge1xuICAgICAgICByZXR1cm4gdG9rZW4uZXhwcmVzc2lvbjtcbiAgICB9XG5cbiAgICBnZXRNZW1iZXJGbk5hbWUgKHRva2VuKSB7XG4gICAgICAgIHJldHVybiB0b2tlbi5leHByZXNzaW9uLm5hbWUudGV4dDtcbiAgICB9XG5cbiAgICBnZXRLZXlWYWx1ZSAocHJvcCkge1xuICAgICAgICBjb25zdCB7IG5hbWUsIGluaXRpYWxpemVyIH0gPSBwcm9wO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBrZXk6ICAgbmFtZS50ZXh0LFxuICAgICAgICAgICAgdmFsdWU6IHRoaXMuZ2V0U3RyaW5nVmFsdWUoaW5pdGlhbGl6ZXIpXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZ2V0Rml4ZWRTdGFydE9mZnNldCAoc3RhcnQpIHtcbiAgICAgICAgbGV0IGZpeGVkU3RhcnRPZmZzZXQgPSBzdGFydDtcblxuICAgICAgICB3aGlsZSAoL1xccy8udGVzdCh0aGlzLmNvZGVXaXRob3V0Q29tbWVudHNbZml4ZWRTdGFydE9mZnNldF0pKVxuICAgICAgICAgICAgKytmaXhlZFN0YXJ0T2Zmc2V0O1xuXG4gICAgICAgIHJldHVybiBmaXhlZFN0YXJ0T2Zmc2V0O1xuICAgIH1cblxuICAgIGdldExvY2F0aW9uQnlPZmZzZXRzIChzdGFydCwgZW5kKSB7XG4gICAgICAgIGNvbnN0IGZpeGVkU3RhcnQgPSB0aGlzLmdldEZpeGVkU3RhcnRPZmZzZXQoc3RhcnQpO1xuICAgICAgICBjb25zdCBjb2RlQXJyICAgID0gdGhpcy5jb2RlQXJyO1xuICAgICAgICBjb25zdCBsb2MgICAgICAgID0geyBzdGFydDogbnVsbCwgZW5kOiBudWxsIH07XG5cbiAgICAgICAgbGV0IGxpbmUgICAgID0gY29kZUFyclswXTtcbiAgICAgICAgbGV0IHN0YXJ0VG1wID0gZml4ZWRTdGFydDtcbiAgICAgICAgbGV0IGVuZFRtcCAgID0gZW5kO1xuXG4gICAgICAgIGZvciAobGV0IGxpbmVOdW1iZXIgPSAxOyBsaW5lTnVtYmVyIDw9IGNvZGVBcnIubGVuZ3RoOyArK2xpbmVOdW1iZXIsIGxpbmUgPSBjb2RlQXJyW2xpbmVOdW1iZXIgLSAxXSkge1xuICAgICAgICAgICAgc3RhcnRUbXAgLT0gbGluZS5sZW5ndGggKyAxO1xuICAgICAgICAgICAgZW5kVG1wIC09IGxpbmUubGVuZ3RoICsgMTtcblxuICAgICAgICAgICAgaWYgKHN0YXJ0VG1wIDwgMCAmJiAhbG9jLnN0YXJ0KVxuICAgICAgICAgICAgICAgIGxvYy5zdGFydCA9IHsgbGluZTogbGluZU51bWJlciwgY29sdW1uOiBsaW5lLmxlbmd0aCArIHN0YXJ0VG1wICsgMSB9O1xuXG4gICAgICAgICAgICBpZiAoZW5kVG1wIDw9IDAgfHwgbGluZU51bWJlciA9PT0gY29kZUFyci5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgbG9jLmVuZCA9IHsgbGluZTogbGluZU51bWJlciwgY29sdW1uOiBsaW5lLmxlbmd0aCArIGVuZFRtcCArIDEgfTtcblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgbG9jLCBzdGFydDogZml4ZWRTdGFydCwgZW5kIH07XG4gICAgfVxuXG4gICAgZ2V0UlZhbHVlICh0b2tlbikge1xuICAgICAgICByZXR1cm4gdG9rZW4uaW5pdGlhbGl6ZXI7XG4gICAgfVxuXG4gICAgZ2V0U3RyaW5nVmFsdWUgKHRva2VuKSB7XG4gICAgICAgIGNvbnN0IHN0cmluZ1R5cGVzID0gW3RoaXMudG9rZW5UeXBlLlN0cmluZ0xpdGVyYWwsIHRoaXMudG9rZW5UeXBlLlRlbXBsYXRlRXhwcmVzc2lvbl07XG5cbiAgICAgICAgaWYgKHN0cmluZ1R5cGVzLmluZGV4T2YodG9rZW4ua2luZCkgPiAtMSB8fCB0b2tlbi50ZXh0ICYmIHRva2VuLmtpbmQgIT09IHRoaXMudG9rZW5UeXBlLk51bWVyaWNMaXRlcmFsKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0Rm5BcmcodG9rZW4pO1xuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlzQXN5bmNGbiAodG9rZW4pIHtcbiAgICAgICAgY29uc3QgaXNHZW5lcmF0b3JGbiA9ICEhdG9rZW4uYXN0ZXJpc2tUb2tlbjtcbiAgICAgICAgY29uc3QgaXNBc3luY0ZuICAgICA9IHRva2VuLm1vZGlmaWVycyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4ubW9kaWZpZXJzLnNvbWUobW9kaWZpZXIgPT4gbW9kaWZpZXIua2luZCA9PT0gdGhpcy50b2tlblR5cGUuQXN5bmNLZXl3b3JkKTtcblxuICAgICAgICByZXR1cm4gaXNHZW5lcmF0b3JGbiB8fCBpc0FzeW5jRm47XG4gICAgfVxuXG4gICAgZ2V0RnVuY3Rpb25Cb2R5ICh0b2tlbikge1xuICAgICAgICByZXR1cm4gdG9rZW4uYm9keS5zdGF0ZW1lbnRzO1xuICAgIH1cblxuICAgIGZvcm1hdEZuRGF0YSAobmFtZSwgdmFsdWUsIHRva2VuLCBtZXRhID0gW3t9XSkge1xuICAgICAgICBjb25zdCBsb2MgPSB0aGlzLmdldExvY2F0aW9uQnlPZmZzZXRzKHRva2VuLnBvcywgdG9rZW4uZW5kKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZm5OYW1lOiBuYW1lLFxuICAgICAgICAgICAgdmFsdWU6ICB2YWx1ZSxcbiAgICAgICAgICAgIGxvYzogICAgbG9jLmxvYyxcbiAgICAgICAgICAgIHN0YXJ0OiAgbG9jLnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiAgICBsb2MuZW5kLFxuICAgICAgICAgICAgbWV0YTogICBtZXJnZSh7fSwgLi4ubWV0YSlcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhbmFseXplTWVtYmVyRXhwICh0b2tlbikge1xuICAgICAgICBsZXQgZXhwICAgICAgICAgPSB0b2tlbjtcbiAgICAgICAgY29uc3QgdG9rZW5UeXBlID0gdGhpcy50b2tlblR5cGU7XG4gICAgICAgIGNvbnN0IGNhbGxTdGFjayA9IFtleHBdO1xuXG4gICAgICAgIHdoaWxlIChleHAua2luZCAhPT0gdGhpcy50b2tlblR5cGUuSWRlbnRpZmllcikge1xuICAgICAgICAgICAgZXhwID0gZXhwLmV4cHJlc3Npb24gfHwgZXhwLnRhZztcblxuICAgICAgICAgICAgY2FsbFN0YWNrLnB1c2goZXhwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLmdldE1ldGFJbmZvKGNhbGxTdGFjay5zbGljZSgpKTtcblxuICAgICAgICBpZiAoZXhwICYmIHRoaXMuaXNBcGlGbihleHAudGV4dCkpIHtcbiAgICAgICAgICAgIGxldCBwYXJlbnRFeHAgPSBjYWxsU3RhY2sucG9wKCk7XG5cbiAgICAgICAgICAgIHdoaWxlIChwYXJlbnRFeHApIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50RXhwLmtpbmQgPT09IHRva2VuVHlwZS5DYWxsRXhwcmVzc2lvbiAmJiBwYXJlbnRFeHAuZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWxsZWVUeXBlICAgICA9IHBhcmVudEV4cC5leHByZXNzaW9uLmtpbmQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxlZU1lbWJlckZuID0gY2FsbGVlVHlwZSA9PT0gdG9rZW5UeXBlLlByb3BlcnR5QWNjZXNzRXhwcmVzc2lvbiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudEV4cC5leHByZXNzaW9uLm5hbWUudGV4dDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGVja0V4cERlZmluZVRhcmdldE5hbWUoY2FsbGVlVHlwZSwgY2FsbGVlTWVtYmVyRm4pKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0Rm5EYXRhKGV4cC50ZXh0LCB0aGlzLmZvcm1hdEZuQXJnKHBhcmVudEV4cC5hcmd1bWVudHNbMF0pLCB0b2tlbiwgbWV0YSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudEV4cC5raW5kID09PSB0b2tlblR5cGUuVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uICYmIHBhcmVudEV4cC50YWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFnVHlwZSAgICAgPSBwYXJlbnRFeHAudGFnLmtpbmQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhZ01lbWJlckZuID0gdGFnVHlwZSA9PT0gdG9rZW5UeXBlLlByb3BlcnR5QWNjZXNzRXhwcmVzc2lvbiAmJiBwYXJlbnRFeHAudGFnLm5hbWUudGV4dDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGVja0V4cERlZmluZVRhcmdldE5hbWUodGFnVHlwZSwgdGFnTWVtYmVyRm4pKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0Rm5EYXRhKGV4cC50ZXh0LCB0aGlzLmZvcm1hdEZuQXJnKHBhcmVudEV4cCksIHRva2VuLCBtZXRhKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwYXJlbnRFeHAgPSBjYWxsU3RhY2sucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBmb3JtYXRGbkFyZyAoYXJnKSB7XG4gICAgICAgIGlmIChhcmcudGVtcGxhdGVTcGFucylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENvbXB1dGVkTmFtZVN0cmluZyh7IHBvczogYXJnLnBvcywgZW5kOiBhcmcuZW5kIH0pO1xuXG4gICAgICAgIGlmIChhcmcuaGVhZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENvbXB1dGVkTmFtZVN0cmluZyh7IHBvczogYXJnLnRlbXBsYXRlLnBvcywgZW5kOiBhcmcudGVtcGxhdGUuZW5kIH0pO1xuXG4gICAgICAgIGlmIChhcmcudGVtcGxhdGUpXG4gICAgICAgICAgICByZXR1cm4gYXJnLnRlbXBsYXRlLnRleHQgfHwgdGhpcy5nZXRDb21wdXRlZE5hbWVTdHJpbmcoeyBwb3M6IGFyZy50ZW1wbGF0ZS5wb3MsIGVuZDogYXJnLnRlbXBsYXRlLmVuZCB9KTtcblxuICAgICAgICBpZiAoYXJnLmtpbmQgPT09IHRoaXMudG9rZW5UeXBlLklkZW50aWZpZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDb21wdXRlZE5hbWVTdHJpbmcoeyBwb3M6IGFyZy5wb3MsIGVuZDogYXJnLmVuZCB9KTtcblxuICAgICAgICBpZiAoYXJnLnRleHQgJiYgYXJnLmtpbmQgIT09IHRoaXMudG9rZW5UeXBlLk51bWVyaWNMaXRlcmFsKVxuICAgICAgICAgICAgcmV0dXJuIGFyZy50ZXh0O1xuXG4gICAgICAgIGlmIChhcmcua2luZCA9PT0gdGhpcy50b2tlblR5cGUuVHlwZUFzc2VydGlvbkV4cHJlc3Npb24pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXRGbkFyZyhhcmcuZXhwcmVzc2lvbik7XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZ2V0Rm5DYWxsICh0b2tlbikge1xuICAgICAgICBpZiAodGhpcy5pc0FwaUZuKHRva2VuLmV4cHJlc3Npb24udGV4dCkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXRGbkRhdGEodG9rZW4uZXhwcmVzc2lvbi50ZXh0LCB0aGlzLmZvcm1hdEZuQXJnKHRva2VuLmFyZ3VtZW50c1swXSksIHRva2VuKTtcblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBnZXRUYWdnZWRUZW1wbGF0ZUV4cCAodG9rZW4pIHtcbiAgICAgICAgaWYgKHRoaXMuaXNBcGlGbih0b2tlbi50YWcudGV4dCkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXRGbkRhdGEodG9rZW4udGFnLnRleHQsIHRoaXMuZm9ybWF0Rm5BcmcodG9rZW4pLCB0b2tlbik7XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgYW5hbHl6ZUZuQ2FsbCAodG9rZW4pIHtcbiAgICAgICAgY29uc3QgdG9rZW5UeXBlID0gdGhpcy50b2tlblR5cGU7XG5cbiAgICAgICAgaWYgKHRva2VuLmtpbmQgPT09IHRva2VuVHlwZS5Qcm9wZXJ0eUFjY2Vzc0V4cHJlc3Npb24pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hbmFseXplTWVtYmVyRXhwKHRva2VuKTtcblxuICAgICAgICBpZiAodG9rZW4ua2luZCA9PT0gdG9rZW5UeXBlLkNhbGxFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICBjb25zdCBleHBLaW5kID0gdG9rZW4uZXhwcmVzc2lvbi5raW5kO1xuXG4gICAgICAgICAgICBpZiAoZXhwS2luZCA9PT0gdG9rZW5UeXBlLlByb3BlcnR5QWNjZXNzRXhwcmVzc2lvbiB8fCBleHBLaW5kID09PSB0b2tlblR5cGUuQ2FsbEV4cHJlc3Npb24pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYW5hbHl6ZU1lbWJlckV4cCh0b2tlbik7XG5cbiAgICAgICAgICAgIGlmIChleHBLaW5kID09PSB0b2tlblR5cGUuUGFyZW50aGVzaXplZEV4cHJlc3Npb24pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYW5hbHl6ZUZuQ2FsbCh0b2tlbi5leHByZXNzaW9uLmV4cHJlc3Npb24pO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRGbkNhbGwodG9rZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRva2VuLmtpbmQgPT09IHRva2VuVHlwZS5GdW5jdGlvbkV4cHJlc3Npb24gfHwgdG9rZW4ua2luZCA9PT0gdG9rZW5UeXBlLkFycm93RnVuY3Rpb24pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb2xsZWN0VGVzdENhZmVDYWxscyh0aGlzLmdldEZ1bmN0aW9uQm9keSh0b2tlbikpO1xuXG4gICAgICAgIGlmICh0b2tlbi5raW5kID09PSB0b2tlblR5cGUuVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICBpZiAodG9rZW4udGFnLmtpbmQgPT09IHRva2VuVHlwZS5Qcm9wZXJ0eUFjY2Vzc0V4cHJlc3Npb24gfHwgdG9rZW4udGFnLmtpbmQgPT09IHRva2VuVHlwZS5DYWxsRXhwcmVzc2lvbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hbmFseXplTWVtYmVyRXhwKHRva2VuKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VGFnZ2VkVGVtcGxhdGVFeHAodG9rZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcGFyc2UgKGNvZGUpIHtcbiAgICAgICAgLy9OT1RFOiBUeXBlU2NyaXB0IGNhbGN1bGF0ZXMgc3RhcnQgcG9zaXRpb24gb2YgYSB0b2tlbiBpbmNvcnJlY3RseVxuICAgICAgICAvL0l0IGRvZXNuJ3QgY29uc2lkZXIgc3BhY2VzIGFuZCBjb21tZW50cyBiZXR3ZWVuIHRoZSBsYXN0IHRva2VuIGFuZCB0aGUgY3VycmVudCB0b2tlbi5cbiAgICAgICAgLy9TbyB3ZSByZXBsYWNlIGNvbW1lbnRzIHdpdGggc3BhY2Ugc3ltYm9scyB0byBjYWxjdWxhdGUgZml4ZWQgcG9zaXRpb24uXG4gICAgICAgIC8vV2UganVzdCBpbmNyZW1lbnQgcG9zaXRpb24gdW50aWwgd2UgbWVldCBub24gd2hpdGVzcGFjZSBjaGFyYWN0ZXJzXG4gICAgICAgIHRoaXMuY29kZUFyciAgICAgICAgICAgICA9IGNvZGUuc3BsaXQoJ1xcbicpO1xuICAgICAgICB0aGlzLmNvZGVXaXRob3V0Q29tbWVudHMgPSByZXBsYWNlQ29tbWVudHMoY29kZSk7XG5cbiAgICAgICAgY29uc3Qgc291cmNlRmlsZSA9IHRzLmNyZWF0ZVNvdXJjZUZpbGUoJycsIGNvZGUsIFR5cGVTY3JpcHRUZXN0RmlsZUNvbXBpbGVyLl9nZXRUeXBlc2NyaXB0T3B0aW9ucygpLCB0cnVlKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5hbmFseXplKHNvdXJjZUZpbGUuc3RhdGVtZW50cyk7XG4gICAgfVxufVxuXG5jb25zdCBwYXJzZXIgPSBuZXcgVHlwZVNjcmlwdFRlc3RGaWxlUGFyc2VyKCk7XG5cbmV4cG9ydCBjb25zdCBnZXRUeXBlU2NyaXB0VGVzdExpc3QgICAgICAgICA9IHBhcnNlci5nZXRUZXN0TGlzdC5iaW5kKHBhcnNlcik7XG5leHBvcnQgY29uc3QgZ2V0VHlwZVNjcmlwdFRlc3RMaXN0RnJvbUNvZGUgPSBwYXJzZXIuZ2V0VGVzdExpc3RGcm9tQ29kZS5iaW5kKHBhcnNlcik7XG4iXX0=
