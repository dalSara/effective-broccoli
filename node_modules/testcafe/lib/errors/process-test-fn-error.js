'use strict';

exports.__esModule = true;
exports.default = processTestFnError;

var _path = require('path');

var _getCallsite = require('./get-callsite');

var _runtime = require('./runtime');

var _errorList = require('./error-list');

var _errorList2 = _interopRequireDefault(_errorList);

var _testRun = require('./test-run');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const INTERNAL = 'internal/';

function isAssertionErrorCallsiteFrame(frame) {
    var filename = frame.getFileName();

    // NOTE: filter out the internals of node.js and assertion libraries
    return filename && filename.indexOf(_path.sep) > -1 && filename.indexOf(INTERNAL) !== 0 && filename.indexOf(`${_path.sep}node_modules${_path.sep}`) < 0;
}

function processTestFnError(err) {
    if (err && (err.isTestCafeError || err instanceof _errorList2.default)) return err;

    if (err && err.constructor === _runtime.APIError) return new _testRun.UncaughtErrorInTestCode(err.rawMessage, err.callsite);

    if (err instanceof Error) {
        var isAssertionError = err.name === 'AssertionError' || err.constructor.name === 'AssertionError';

        // NOTE: assertion libraries can add their source files to the error stack frames.
        // We should skip them to create a correct callsite for the assertion error.
        var callsite = isAssertionError ? (0, _getCallsite.getCallsiteForError)(err, isAssertionErrorCallsiteFrame) : (0, _getCallsite.getCallsiteForError)(err);

        return isAssertionError ? new _testRun.ExternalAssertionLibraryError(err, callsite) : new _testRun.UncaughtErrorInTestCode(err, callsite);
    }

    return new _testRun.UncaughtNonErrorObjectInTestCode(err);
}
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9lcnJvcnMvcHJvY2Vzcy10ZXN0LWZuLWVycm9yLmpzIl0sIm5hbWVzIjpbInByb2Nlc3NUZXN0Rm5FcnJvciIsIklOVEVSTkFMIiwiaXNBc3NlcnRpb25FcnJvckNhbGxzaXRlRnJhbWUiLCJmcmFtZSIsImZpbGVuYW1lIiwiZ2V0RmlsZU5hbWUiLCJpbmRleE9mIiwic2VwIiwiZXJyIiwiaXNUZXN0Q2FmZUVycm9yIiwiVGVzdENhZmVFcnJvckxpc3QiLCJjb25zdHJ1Y3RvciIsIkFQSUVycm9yIiwiVW5jYXVnaHRFcnJvckluVGVzdENvZGUiLCJyYXdNZXNzYWdlIiwiY2FsbHNpdGUiLCJFcnJvciIsImlzQXNzZXJ0aW9uRXJyb3IiLCJuYW1lIiwiRXh0ZXJuYWxBc3NlcnRpb25MaWJyYXJ5RXJyb3IiLCJVbmNhdWdodE5vbkVycm9yT2JqZWN0SW5UZXN0Q29kZSJdLCJtYXBwaW5ncyI6Ijs7O2tCQXlCd0JBLGtCOztBQXpCeEI7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7QUFFQTs7OztBQU9BLE1BQU1DLFdBQVcsV0FBakI7O0FBRUEsU0FBU0MsNkJBQVQsQ0FBd0NDLEtBQXhDLEVBQStDO0FBQzNDLFFBQUlDLFdBQVdELE1BQU1FLFdBQU4sRUFBZjs7QUFFQTtBQUNBLFdBQU9ELFlBQ0FBLFNBQVNFLE9BQVQsQ0FBaUJDLFNBQWpCLElBQXdCLENBQUMsQ0FEekIsSUFFQUgsU0FBU0UsT0FBVCxDQUFpQkwsUUFBakIsTUFBK0IsQ0FGL0IsSUFHQUcsU0FBU0UsT0FBVCxDQUFrQixHQUFFQyxTQUFJLGVBQWNBLFNBQUksRUFBMUMsSUFBK0MsQ0FIdEQ7QUFJSDs7QUFHYyxTQUFTUCxrQkFBVCxDQUE2QlEsR0FBN0IsRUFBa0M7QUFDN0MsUUFBSUEsUUFBUUEsSUFBSUMsZUFBSixJQUF1QkQsZUFBZUUsbUJBQTlDLENBQUosRUFDSSxPQUFPRixHQUFQOztBQUVKLFFBQUlBLE9BQU9BLElBQUlHLFdBQUosS0FBb0JDLGlCQUEvQixFQUNJLE9BQU8sSUFBSUMsZ0NBQUosQ0FBNEJMLElBQUlNLFVBQWhDLEVBQTRDTixJQUFJTyxRQUFoRCxDQUFQOztBQUVKLFFBQUlQLGVBQWVRLEtBQW5CLEVBQTBCO0FBQ3RCLFlBQUlDLG1CQUFtQlQsSUFBSVUsSUFBSixLQUFhLGdCQUFiLElBQWlDVixJQUFJRyxXQUFKLENBQWdCTyxJQUFoQixLQUF5QixnQkFBakY7O0FBRUE7QUFDQTtBQUNBLFlBQUlILFdBQVdFLG1CQUFtQixzQ0FBb0JULEdBQXBCLEVBQXlCTiw2QkFBekIsQ0FBbkIsR0FBNkUsc0NBQW9CTSxHQUFwQixDQUE1Rjs7QUFFQSxlQUFPUyxtQkFDSCxJQUFJRSxzQ0FBSixDQUFrQ1gsR0FBbEMsRUFBdUNPLFFBQXZDLENBREcsR0FFSCxJQUFJRixnQ0FBSixDQUE0QkwsR0FBNUIsRUFBaUNPLFFBQWpDLENBRko7QUFHSDs7QUFFRCxXQUFPLElBQUlLLHlDQUFKLENBQXFDWixHQUFyQyxDQUFQO0FBQ0giLCJmaWxlIjoiZXJyb3JzL3Byb2Nlc3MtdGVzdC1mbi1lcnJvci5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHNlcCB9IGZyb20gJ3BhdGgnO1xuaW1wb3J0IHsgZ2V0Q2FsbHNpdGVGb3JFcnJvciB9IGZyb20gJy4vZ2V0LWNhbGxzaXRlJztcbmltcG9ydCB7IEFQSUVycm9yIH0gZnJvbSAnLi9ydW50aW1lJztcbmltcG9ydCBUZXN0Q2FmZUVycm9yTGlzdCBmcm9tICcuL2Vycm9yLWxpc3QnO1xuXG5pbXBvcnQge1xuICAgIFVuY2F1Z2h0RXJyb3JJblRlc3RDb2RlLFxuICAgIFVuY2F1Z2h0Tm9uRXJyb3JPYmplY3RJblRlc3RDb2RlLFxuICAgIEV4dGVybmFsQXNzZXJ0aW9uTGlicmFyeUVycm9yXG59IGZyb20gJy4vdGVzdC1ydW4nO1xuXG5cbmNvbnN0IElOVEVSTkFMID0gJ2ludGVybmFsLyc7XG5cbmZ1bmN0aW9uIGlzQXNzZXJ0aW9uRXJyb3JDYWxsc2l0ZUZyYW1lIChmcmFtZSkge1xuICAgIHZhciBmaWxlbmFtZSA9IGZyYW1lLmdldEZpbGVOYW1lKCk7XG5cbiAgICAvLyBOT1RFOiBmaWx0ZXIgb3V0IHRoZSBpbnRlcm5hbHMgb2Ygbm9kZS5qcyBhbmQgYXNzZXJ0aW9uIGxpYnJhcmllc1xuICAgIHJldHVybiBmaWxlbmFtZSAmJlxuICAgICAgICAgICBmaWxlbmFtZS5pbmRleE9mKHNlcCkgPiAtMSAmJlxuICAgICAgICAgICBmaWxlbmFtZS5pbmRleE9mKElOVEVSTkFMKSAhPT0gMCAmJlxuICAgICAgICAgICBmaWxlbmFtZS5pbmRleE9mKGAke3NlcH1ub2RlX21vZHVsZXMke3NlcH1gKSA8IDA7XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcHJvY2Vzc1Rlc3RGbkVycm9yIChlcnIpIHtcbiAgICBpZiAoZXJyICYmIChlcnIuaXNUZXN0Q2FmZUVycm9yIHx8IGVyciBpbnN0YW5jZW9mIFRlc3RDYWZlRXJyb3JMaXN0KSlcbiAgICAgICAgcmV0dXJuIGVycjtcblxuICAgIGlmIChlcnIgJiYgZXJyLmNvbnN0cnVjdG9yID09PSBBUElFcnJvcilcbiAgICAgICAgcmV0dXJuIG5ldyBVbmNhdWdodEVycm9ySW5UZXN0Q29kZShlcnIucmF3TWVzc2FnZSwgZXJyLmNhbGxzaXRlKTtcblxuICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB2YXIgaXNBc3NlcnRpb25FcnJvciA9IGVyci5uYW1lID09PSAnQXNzZXJ0aW9uRXJyb3InIHx8IGVyci5jb25zdHJ1Y3Rvci5uYW1lID09PSAnQXNzZXJ0aW9uRXJyb3InO1xuXG4gICAgICAgIC8vIE5PVEU6IGFzc2VydGlvbiBsaWJyYXJpZXMgY2FuIGFkZCB0aGVpciBzb3VyY2UgZmlsZXMgdG8gdGhlIGVycm9yIHN0YWNrIGZyYW1lcy5cbiAgICAgICAgLy8gV2Ugc2hvdWxkIHNraXAgdGhlbSB0byBjcmVhdGUgYSBjb3JyZWN0IGNhbGxzaXRlIGZvciB0aGUgYXNzZXJ0aW9uIGVycm9yLlxuICAgICAgICB2YXIgY2FsbHNpdGUgPSBpc0Fzc2VydGlvbkVycm9yID8gZ2V0Q2FsbHNpdGVGb3JFcnJvcihlcnIsIGlzQXNzZXJ0aW9uRXJyb3JDYWxsc2l0ZUZyYW1lKSA6IGdldENhbGxzaXRlRm9yRXJyb3IoZXJyKTtcblxuICAgICAgICByZXR1cm4gaXNBc3NlcnRpb25FcnJvciA/XG4gICAgICAgICAgICBuZXcgRXh0ZXJuYWxBc3NlcnRpb25MaWJyYXJ5RXJyb3IoZXJyLCBjYWxsc2l0ZSkgOlxuICAgICAgICAgICAgbmV3IFVuY2F1Z2h0RXJyb3JJblRlc3RDb2RlKGVyciwgY2FsbHNpdGUpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgVW5jYXVnaHROb25FcnJvck9iamVjdEluVGVzdENvZGUoZXJyKTtcbn1cbiJdfQ==
